%{
//
dynload "libatsdoc/dynloadall.dats"
//
#include "./../ATEXT/int2proginats.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter
id="Cinteraction">
#title("Interaction with C")

#para('\

ATS and C share precisely the same native/flat/unboxed data representation.
As a consequence, there is no need for wrapping/unwrapping or
boxing/unboxing when calling from C a function implemented in ATS or vice
versa, and there is also no run-time overhead for doing so. To a large
extent, ATS can be considered a front-end to C that is equipped with a
highly expressive type system and a localizable template system. In
particular, ATS can often be effectively employed to turn a large task into
subtasks of coherent interfaces, which can be implemented in ATS, C or some
other langauges and then be assembled to form a solution to the orginal
task.\

')

#para('\

As it can be expected, C code that appears directly in ATS does not go
through the kind of rigorous typechecking like ATS code should. So it is
recommended that the programmer be extra cautious when making direct use of
C code inside ATS code. In practice, my own experience clearly indicates
that the portion of C code inside my ATS code is highly likely to be the
culprit for most of encountered bugs.

')

#para("\

The code employed for illustration in this chapter plus some additional
code for testing is available #mycodelink("CHAP_CINTERACT/", "on-line").\

")

<!-- ****** ****** -->

<sect1
id="external_name">
#title("External Global Names")

#para("\

A function declared in ATS can be given a global name of C-style so as to
allow the function to appear in both ATS code and C code.  In particular,
the function can be implemented in ATS and called in C or vice versa.\

")

#para("\

In the following code, we see that two functions are declared:

#atscode('\
extern
fun fact (n: int): int
extern
fun fact2 (n: int, res: int): int = "ext\#fact2_in_c"
')

The first function #dyncode("fact") does not have a global name while the
second function #dyncode("fact2") is assigned a global name
#dyncode("fact2_in_c").  The symbol #keycode("ext\#") indicates that
#dyncode("fact2_in_c") is treated as a global function in C and its
prototype needs to be declared (via the #dyncode("extern") keyword) before
it can be called.

")

#para("\

Let us assume that #dyncode("fact") can be implemented as follows:

#atscode('\
implement fact (n) = fact2 (n, 1)
')

When compiling this implementation, the ATS compiler needs to form function
names in the generated C code to refer to #dyncode("fact") and
#dyncode("fact2").  For the former, the function name in the C code is
determined by a set of rules (which take into account the issue of
namespace).  For the latter, the function name is simply chosen to be the
assigned global name #dyncode("fact2_in_c"). As is suggested by the name of
#dyncode("fact2_in_c"), this function can be directly implemented in C as
follows:

<informalexample><programlisting>
<![CDATA[int
fact2_in_c (int n, int res)
{
  while (n > 0) { res *= n ; n -= 1 ; } ; return res ;
}
]]></programlisting></informalexample>

It is also allowed to implement #dyncode("fact2") in ATS
directly as is shown below:

#atscode('\
implement
fact2 (n, res) = if n > 0 then fact2 (n-1, n*res) else res
')

This implementation of #dyncode("fact2") can be called in C
through the name #dyncode("fact2_in_c").\

")

#para('\

If both #dyncode("fact2") and #dyncode("fact2_in_c") are implemented (the
former in ATS and the latter in C), then a linking-time error is to be
issued to indicate that #dyncode("fact2_in_c") is implemented repeatedly.\

')

#para('\

One can also declare #dyncode("fact2") as follows:

#atscode('\
extern
fun fact2 (n: int, res: int): int = "mac\#fact2_in_c"
')

The symbol #keycode("mac\#") indicates that #dyncode("fact2_in_c") is
treated like a macro in C. In particular, #dyncode("fact2_in_c") can be
called without its prototype being declared first. As a matter of fact, it
may not even have a prototype. This style of declaration naturally expects
#dyncode("fact2_in_c") to be implemented in C directly.\

')

#para('\

It is also allowed to use #keycode("sta\#") in place of #keycode("mac\#"):

#atscode('\
extern
fun fact2 (n: int, res: int): int = "sta\#fact2_in_c"
')

If declared in this style, which only occurs rarely in practice,
then #dyncode("fact2_in_c") is treated like a static function in C.\

')

</sect1><!--id="external_global_names"-->

<!-- ****** ****** -->

<sect1
id="external_types_and_values">
#title("External Types and Values in ATS")

#para("\

External types and values can be readily formed in ATS to refer to types
and values declared in C.

")

#para("\

Suppose that there is a type in C of the name #stacode("some_type_in_c"),
then this type can be referred to in ATS as
#stacode('$extype"some_type_in_c"'). For instance, type definitions are
introduced in the following code for some external types in C:

#atscode('\
typedef Cint = $extype"int"
typedef Clint = $extype"long int"
typedef Cllint = $extype"long long int"
typedef Cint2 = $extype"struct{ int x; int y; }"
')

Suppose that there is a value in C of the name #dyncode("some_value_in_c"),
then this value can be referred to in ATS as #dyncode('$extval(#stacode('T'), "some_value_in_c")'),
where T is a type in ATS assigned to this value.  For instance, macro
definitions are introduced in the following code for some external values
in C:

#atscode('\
macdef NULL = $extype(ptr, "0")
macdef stdin_ref = $extype(FILEref, "stdin")
macdef stdout_ref = $extype(FILEref, "stdout")
')

External value can also be formed to refer to functions in C as done
in the following code:

#atscode('\
macdef atoi = $extype(string -> int, "atoi")
macdef atol = $extype(string -> lint, "atol")
macdef atof = $extype(string -> double, "atof")
')

Note that there are other ways in ATS that are often more approriate for
directly referring to functions in C.  Typically, the primary purpose of
forming an external value in ATS is to allow a constant declared in C to be
directly referred to in ATS code.

")

</sect1><!--id="external_types_and_values"-->

<!-- ****** ****** -->

<sect1
id="inclusion_of_external_code">
#title("Inclusion of External Code in ATS")

#para('\

Just like including assembly code inside C code, it is straightforward to
include C code inside ATS code. For instance, the example appearing at the
beginning of this chapter can be written as follows in a single file:

#atscode('\
extern
fun fact (n: int): int
extern
fun fact2 (n: int, res: int): int = "ext\#fact2_in_c"

implement fact (n) = fact2 (n, 1)

%{
int
fact2_in_c (int n, int res)
{
  while (n > 0) { res *= n ; n -= 1 ; } ; return res ;
}
%}
')#comment("atscode")

For C code to appear inside ATS code, it needs to enclosed by the symbols
#keycode("%{") (opening) and #keycode("%}") (closing). Essentially,
whatever code appearing between these two symbols is pasted into the
generated C code at an unspecified position. If the enclosed code is
intended to be put at the beginning of the generated C code, then the
symbol #keycode("%{^") should be used in place of #keycode("%{").  If the
enclosed code is intended to be put at the bottom of the generated C code,
then the symbol #keycode("%{$") should be used in place of #keycode("%{").

')

#para('\

It is also allowed to put C code between the symbols
#keycode("%{#") and #keycode("%}"). Suppose that there is a file of the
name #filename("foo.sats") that contains C code included in this manner.
If #filename("foo.sats") is staloaded in another file of the name
#filename("foo.dats"), then the lines between #keycode("%{#") and
#keycode("%}") in #filename("foo.sats") are pasted into the C code
generated from compiling #filename("foo.dats").

')

</sect1><!--id="inclusion_of_external_code"-->

<!-- ****** ****** -->

<sect1
id="calling_external_functions">
#title("Calling External Functions in ATS")

#para('\

It is straightforward to make calls to external functions in ATS.
For instance, the following code demonstrates a typical way to do so:

#atscode('\
local
extern
fun __fprintf
  : (FILEref, string(*fmt*), int, int) -> int = "mac\#fprintf"
in (* in of [local] *)
//
val N = 12
val _ = __fprintf (stdout_ref, "fact(%i) = %i\\\\n", N, fact(N))
//
end // end of [local]
')

where the function #dyncode("fprintf") (declared in #filename("stdio.h"))
is given a (local) name #dyncode("__fprintf") and an interface appropriate
for the call to be made.

')

#para('\

There is also built-in support for calling external functions in ATS directly.
For instance, the following code does essentially the same as the code
presented above:

#atscode('\
val N = 12
val _ = $extfcall(int, "fprintf", stdout_ref, "fact(%i) = %i\\\\n", N, fact(N))
')

When #dyncode("$extfcall") is employed to make an external function call,
its first argument is the return type of the call, and its second argument
is the name of the called function (represented as a string), and its rest
of arguments are the arguments of the called function.

')

</sect1><!--id="calling_external_functions"-->

<!-- ****** ****** -->

<sect1
id="unsafe_c-style_programming_in_ats">
#title("Unsafe C-style programming in ATS")

#para("\

ATS is probably not a programming language easy for one to write code in.
While ATS provides many features to support safe (low-level) programming,
it may take a long time and some great efforts for a programmer to learn
and then master these features before he or she can make effective use of
them.  In this section, I would like to present some ATS code written in
C-style that makes typical use of certan unsafe programming features in
ATS. This is a programming style that should be familiar to any programmer
who can write C code competently.

")

#para("\

There are always occasions where one may find it sensible to program in
unsafe C-style. Sometimes, one just wants to get a running implementation
and then relies on testing to detect and fix bugs. Sometimes, one simply
does not know enough of ATS needed to implement a function in a safe
programming manner. This list of occasions can be readily extended as one
wishes. I myself do unsafe C-style programming in ATS frequently, and I see
it as a necessary skill for anyone who not just only wants to be able to
write code in ATS but also wants to do it highly productively. Let us
now see some a concrete example of unsafe C-style programming in ATS.

")

#para("\

Suppose that we want to implement a function for comparing two given
strings according to the standard lexicographic ordering. Let us name
the function #dyncode("strcmp") and give it the following interface:

#atscode('\
fun strcmp (str1: string, str2: string): int
')

Given two strings #dyncode("str1") and #dyncode("str2"),
#dyncode("strcmp(str1, str2)") is expected to return 1, -1, and 0 if
#dyncode("str1") is greater than, less than, and equal to #dyncode("str2"),
respectively. An implementation of #dyncode("strcmp") is given as follows:

#atscode('\

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
strcmp (str1, str2) = let
//
fun loop
  (p1: ptr, p2: ptr): int = let
//
val c1 = $UN.ptr0_get<uchar> (p1)
val c2 = $UN.ptr0_get<uchar> (p2)
//
in
  case+ 0 of
  | _ when c1 > c2 =>  1
  | _ when c1 < c2 => ~1
  | _ (* c1 = c2 *) =>
    (
      if $UN.cast{int}(c1) = 0
        then 0 else loop (ptr0_succ<uchar> (p1), ptr0_succ<uchar> (p2))
      // end of [if]
    )
end (* end of [loop] *)
//
in
  loop (string2ptr(str1), string2ptr(str2))
end (* end of [strcmp] *)
')

For a programmer familar with C, the above implementation of
#dyncode("strcmp") should be easily accessible.  There are a variety of
unsafe functions declared in #myatscodelink("prelude/SATS/unsafe.sats",
"unsafe.sats"). Given a type T and a pointer p, #dyncode("ptr0_get&lt;T&gt;
(p)") fetches the value of the type T stored at the location to which p
points.  Note that #dyncode("ptr0_get") is inherently unsafe as there is
simply no guarantee that p actually points to a valid memory location where
a value of the type T is stored.  The function #dyncode("cast"), which is
also inherently unsafe, casts the type of a given value into any chosen
type.  The function template #dyncode("ptr0_succ"), which is declared in
#myatscodelink("prelude/SATS/pointer.sats", "pointer.sats"), is
type-safe. Given a type T, #dyncode("ptr0_succ&lt;T&gt; (p)") returns the
pointer that is n bytes after p, where n equals the size of T.

")

#para("\

Please find the entire code for this example
#mycodelink("CHAP_CINTERACT/strcmp.dats", "on-line").

")

#para("\

For a function like #dyncode("strcmp"), one can readily implement it in C
directly. For instance, an implementation of #dyncode("strcmp") in C, which
is essentially a translation of the above implementation of #dyncode("strcmp")
in ATS, is given as follows:

#atscode('\
int strcmp (char *p1, char *p2)
{
  int res ;
  unsigned char c1, c2;
  while (1)
  {
    c1 = *p1; c2 = *p2;
    if (c1 > c2) { res =  1; break; } ;
    if (c1 < c2) { res = -1; break; } ;
    if ((int)c1==0) { res = 0 ; break ; } else { p1++; p2++; } ;
  }
  return res ;
}
')

However, writing ATS code in C-style can often have advantages over writing
C code directly. For instance, there is direct support in ATS but not in C
for implementing function templates.  In C, one is essentially forced to
rely on rather involved use of macros to implement function templates,
which makes the code not only difficult to follow but also notoriously
error-prone. Let us now see as follows a function template implementation
in ATS that is partly type-unsafe.

")

#para("\

Suppose we want a function for copying into a given array the elements
stored in a list. Let us name the function #dyncode("array_copy_from_list")
and give it the following interface:

#atscode('\
fun{a:t@ype}
array_copy_from_list (A: array0(a), xs: list0(a)): void
')

Given a type T, #stacode("array0(T)") is for an array0-value containing a
pointer p and a size n such that p points to a C-style array storing n
elements of the type T.

")

#para("\

For the moment, let us require that the size of the array A equals the
length of the list xs when #dyncode("array_copy_from_list(A, xs)") is
called.  Following is an implementation of #dyncode("array_copy_from_list")
in ATS that makes use of an unsafe function (#dyncode("ptr0_set")) declared
in #myatscodelink("prelude/SATS/unsafe.sats", "unsafe.sats"):

#atscode('\
staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
array_copy_from_list (A, xs) = let
//
fun loop
(
  p: ptr, xs: list0 (a)
) : void =
(
case+ xs of
| list0_nil () => ()
| list0_cons (x, xs) => let
    val () = $UN.ptr0_set<a> (p, x) in loop (ptr0_succ<a> (p), xs)
  end // end of [list0_cons]
) (* end of [loop] *)
//
in
  loop (array0_get_ref(A), xs)
end // end of [array_copy_from_list]
')

Given a type T, a pointer p, and a value x of the type T,
#dyncode("ptr0_set&lt;T&gt; (p, x)") stores the value x at the location to
which p points.  Like #dyncode("ptr0_get"), #dyncode("ptr0_set") is
inherently unsafe as there is simply no guarantee that p actually points to
a valid memory location where a value of the type T can be stored.  The
function #dyncode("array0_get_ref"), which is declared in
#myatscodelink("libats/ML/SATS/array0.sats", "array0.sats"), returns the
pointer to the C-style array associated with a given array0-value.

")

#para("\

Please find the entire code for this example
#mycodelink("CHAP_CINTERACT/ArrayCopyFromList.dats", "on-line").

")

</sect1><!--id="unsafe_c-style_programming_in_ats"-->

<!-- ****** ****** -->

</chapter>

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
