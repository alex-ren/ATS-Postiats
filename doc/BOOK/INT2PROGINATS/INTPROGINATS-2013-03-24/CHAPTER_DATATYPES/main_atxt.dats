(*
main.atxt: 1(line=1, offs=1) -- 86(line=8, offs=3)
*)

//
dynload
"libatsdoc/dynloadall.dats"
//
#include "./../proginatsatxt.dats"
//

(*
main.atxt: 89(line=9, offs=2) -- 171(line=11, offs=3)
*)
val __tok1 = comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
val () = theAtextMap_insert_str ("__tok1", __tok1)

(*
main.atxt: 207(line=13, offs=22) -- 218(line=13, offs=33)
*)
val __tok3 = timestamp()
val () = theAtextMap_insert_str ("__tok3", __tok3)

(*
main.atxt: 173(line=12, offs=2) -- 222(line=14, offs=3)
*)
val __tok2 = comment("\n\
Time of Generation: #__tok3$\
")
val () = theAtextMap_insert_str ("__tok2", __tok2)

(*
main.atxt: 529(line=22, offs=28) -- 543(line=22, offs=42)
*)
val __tok5 = code("intopt")
val () = theAtextMap_insert_str ("__tok5", __tok5)

(*
main.atxt: 547(line=24, offs=2) -- 642(line=28, offs=3)
*)
val __tok6 = atscode("\
datatype intopt =
  | intopt_none of () | intopt_some of (int)
// end of [intopt]
")
val () = theAtextMap_insert_str ("__tok6", __tok6)

(*
main.atxt: 688(line=30, offs=45) -- 702(line=30, offs=59)
*)
val __tok7 = code("intopt")
val () = theAtextMap_insert_str ("__tok7", __tok7)

(*
main.atxt: 705(line=31, offs=2) -- 724(line=31, offs=21)
*)
val __tok8 = code("intopt_none")
val () = theAtextMap_insert_str ("__tok8", __tok8)

(*
main.atxt: 749(line=31, offs=46) -- 768(line=31, offs=65)
*)
val __tok9 = code("intopt_some")
val () = theAtextMap_insert_str ("__tok9", __tok9)

(*
main.atxt: 801(line=32, offs=32) -- 822(line=32, offs=53)
*)
val __tok10 = code("intopt_none()")
val () = theAtextMap_insert_str ("__tok10", __tok10)

(*
main.atxt: 828(line=33, offs=2) -- 850(line=33, offs=24)
*)
val __tok11 = code("intopt_some(1)")
val () = theAtextMap_insert_str ("__tok11", __tok11)

(*
main.atxt: 879(line=33, offs=53) -- 893(line=33, offs=67)
*)
val __tok12 = code("intopt")
val () = theAtextMap_insert_str ("__tok12", __tok12)

(*
main.atxt: 275(line=18, offs=2) -- 1168(line=38, offs=3)
*)
val __tok4 = para("\
A datatype is like a tagged union type. For each datatype, there are
some constructors associated with it, and these constructors are needed for
constructing values of the datatype.  As an example, the following syntax
declares a datatype named #__tok5$:

#__tok6$

There are two constructors associated with #__tok7$:
#__tok8$, which is nullary, and #__tok9$,
which is unary. For instance, #__tok10$ and
#__tok11$ are two values of the type #__tok12$.
In order for accessing components in such values, a mechanism often
referred to as pattern-matching is provided in ATS. I will demonstrate
through examples that datatypes plus pattern matching can offer not only
great convenience in programming but also clarity in code.
")
val () = theAtextMap_insert_str ("__tok4", __tok4)

(*
main.atxt: 1169(line=38, offs=4) -- 1184(line=38, offs=19)
*)
val __tok13 = comment("para")
val () = theAtextMap_insert_str ("__tok13", __tok13)

(*
main.atxt: 1298(line=42, offs=43) -- 1341(line=42, offs=86)
*)
val __tok15 = mycodelink("CHAPTER_DATATYPES/", "on-line")
val () = theAtextMap_insert_str ("__tok15", __tok15)

(*
main.atxt: 1187(line=40, offs=2) -- 1345(line=43, offs=3)
*)
val __tok14 = para("\
The code employed for illustration in this chapter plus some
additional code for testing is available #__tok15$.
")
val () = theAtextMap_insert_str ("__tok14", __tok14)

(*
main.atxt: 1487(line=54, offs=2) -- 1602(line=57, offs=3)
*)
val __tok17 = para("\
Certain constant values such booleans, chars, floating
point numbers, integers and strings are patterns.
")
val () = theAtextMap_insert_str ("__tok17", __tok17)

(*
main.atxt: 1628(line=61, offs=2) -- 1670(line=63, offs=3)
*)
val __tok18 = para("\
The void value () is a pattern.
")
val () = theAtextMap_insert_str ("__tok18", __tok18)

(*
main.atxt: 1727(line=68, offs=24) -- 1736(line=68, offs=33)
*)
val __tok20 = code("_")
val () = theAtextMap_insert_str ("__tok20", __tok20)

(*
main.atxt: 1696(line=67, offs=2) -- 1778(line=69, offs=3)
*)
val __tok19 = para("\
The underscore symbol #__tok20$ represents a special wildcard pattern.
")
val () = theAtextMap_insert_str ("__tok19", __tok19)

(*
main.atxt: 1804(line=73, offs=2) -- 1838(line=75, offs=3)
*)
val __tok21 = para("\
Variables are patterns.
")
val () = theAtextMap_insert_str ("__tok21", __tok21)

(*
main.atxt: 1864(line=79, offs=2) -- 1933(line=81, offs=3)
*)
val __tok22 = para("
A tuple of patterns, either boxed or unboxed, is a pattern.
")
val () = theAtextMap_insert_str ("__tok22", __tok22)

(*
main.atxt: 1959(line=85, offs=2) -- 2029(line=87, offs=3)
*)
val __tok23 = para("
A record of patterns, either boxed or unboxed, is a pattern.
")
val () = theAtextMap_insert_str ("__tok23", __tok23)

(*
main.atxt: 2055(line=91, offs=2) -- 2154(line=94, offs=3)
*)
val __tok24 = para("
Given a constructor C, a pattern can be formed by applying C to
a given list of patterns.
")
val () = theAtextMap_insert_str ("__tok24", __tok24)

(*
main.atxt: 2229(line=99, offs=43) -- 2239(line=99, offs=53)
*)
val __tok26 = code("as")
val () = theAtextMap_insert_str ("__tok26", __tok26)

(*
main.atxt: 2277(line=100, offs=17) -- 2287(line=100, offs=27)
*)
val __tok27 = code("as")
val () = theAtextMap_insert_str ("__tok27", __tok27)

(*
main.atxt: 2180(line=98, offs=2) -- 2304(line=101, offs=3)
*)
val __tok25 = para("
Given a variable x and a pattern pat, (x #__tok26$ pat) is a referenced
pattern, where #__tok27$ is a keyword.
")
val () = theAtextMap_insert_str ("__tok25", __tok25)

(*
main.atxt: 2330(line=105, offs=2) -- 2398(line=107, offs=3)
*)
val __tok28 = para("
Some other forms of patterns will be introduced elsewhere.
")
val () = theAtextMap_insert_str ("__tok28", __tok28)

(*
main.atxt: 2703(line=116, offs=2) -- 2712(line=116, offs=11)
*)
val __tok29 = code("_")
val () = theAtextMap_insert_str ("__tok29", __tok29)

(*
main.atxt: 1395(line=48, offs=2) -- 2755(line=117, offs=3)
*)
val __tok16 = para("\
Patterns in ATS can be defined inductively as follows:

<itemizedlist>

<listitem>
#__tok17$
</listitem>

<listitem>
#__tok18$
</listitem>

<listitem>
#__tok19$
</listitem>

<listitem>
#__tok21$
</listitem>

<listitem>
#__tok22$
</listitem>

<listitem>
#__tok23$
</listitem>

<listitem>
#__tok24$
</listitem>

<listitem>
#__tok25$
</listitem>

<listitem>
#__tok28$
</listitem>

</itemizedlist>

Each variable can occur at most once in a given pattern, and this is
referred as the linearity restriction on variables in patterns. For
instance, (x, x) is not a legal pattern as the variable x appears twice in
it. However, this restriction does not apply to the variable
#__tok29$, which represents the wildcard pattern.
")
val () = theAtextMap_insert_str ("__tok16", __tok16)

(*
main.atxt: 2756(line=117, offs=4) -- 2771(line=117, offs=19)
*)
val __tok30 = comment("para")
val () = theAtextMap_insert_str ("__tok30", __tok30)

(*
main.atxt: 3214(line=136, offs=2) -- 3332(line=139, offs=3)
*)
val __tok32 = para("\
A value that matches a constant pattern must be the same constant, and this
matching generates no bindings.
")
val () = theAtextMap_insert_str ("__tok32", __tok32)

(*
main.atxt: 3358(line=143, offs=2) -- 3456(line=146, offs=3)
*)
val __tok33 = para("\
The void value () only matches the pattern (), and this matching generates
no bindings.
")
val () = theAtextMap_insert_str ("__tok33", __tok33)

(*
main.atxt: 3482(line=150, offs=2) -- 3575(line=152, offs=3)
*)
val __tok34 = para("\
Any value can match the wildcard pattern, and this matching generates no bindings.
")
val () = theAtextMap_insert_str ("__tok34", __tok34)

(*
main.atxt: 3601(line=156, offs=2) -- 3725(line=159, offs=3)
*)
val __tok35 = para("\
Any value can match a variable pattern, and this matching generates a
binding between the variable and the value.
")
val () = theAtextMap_insert_str ("__tok35", __tok35)

(*
main.atxt: 3751(line=163, offs=2) -- 4132(line=170, offs=3)
*)
val __tok36 = para("\
A tuple value matches a tuple pattern if they are of the same length
and each value component in the former matches the corresponding pattern
component in the latter, and this matching generates a collection of
bindings that is the union of the bindings generated from matching the
value components in the tuple value against the pattern components in the
tuple pattern.
")
val () = theAtextMap_insert_str ("__tok36", __tok36)

(*
main.atxt: 4158(line=174, offs=2) -- 4546(line=181, offs=3)
*)
val __tok37 = para("\
A record value matches a record pattern if they have the
same field names and each value component in the former matches the
corresponding pattern component in the latter, and this matching generates
a collection of bindings that is the union of the bindings generated from
matching the value components in the record value against the pattern
components in the record pattern.
")
val () = theAtextMap_insert_str ("__tok37", __tok37)

(*
main.atxt: 4572(line=185, offs=2) -- 4944(line=192, offs=3)
*)
val __tok38 = para("\
Given a pattern formed by applying a constructor C to
some pattern arguments, a value matches this pattern if the value is formed
by applying C to some value arguments matching the pattern arguments, and
this matching generates a collection of bindings that is the union of the
bindings generated from matching the value arguments against the pattern
arguments.
")
val () = theAtextMap_insert_str ("__tok38", __tok38)

(*
main.atxt: 5009(line=197, offs=32) -- 5019(line=197, offs=42)
*)
val __tok40 = code("as")
val () = theAtextMap_insert_str ("__tok40", __tok40)

(*
main.atxt: 4970(line=196, offs=2) -- 5236(line=201, offs=3)
*)
val __tok39 = para("\
Given a referenced pattern (x #__tok40$ pat), a
value matches the pattern if it matches pat, and this matching generates a
collection of bindings that extends the bindings generated from matching
the value against pat with a binding from x to the value.
")
val () = theAtextMap_insert_str ("__tok39", __tok39)

(*
main.atxt: 2891(line=126, offs=2) -- 5454(line=209, offs=3)
*)
val __tok31 = para("\
Pattern matching means matching values against patterns. In the case
where a value matches a pattern, a collection of bindings are generated
between the variables in the pattern and certain components in the
value. Pattern-matching is performed according to the following set of
rules:

<itemizedlist>

<listitem>
#__tok32$
</listitem>

<listitem>
#__tok33$
</listitem>

<listitem>
#__tok34$
</listitem>

<listitem>
#__tok35$
</listitem>

<listitem>
#__tok36$
</listitem>

<listitem>
#__tok37$
</listitem>

<listitem>
#__tok38$
</listitem>

<listitem>
#__tok39$
</listitem>

</itemizedlist>

Suppose we have a tuple value (0, 1, 2, 3) and a tuple pattern (0, _, x,
y). Then the value matches the pattern and this matching yields bindings
from x and y to 2 and 3, respectively.
")
val () = theAtextMap_insert_str ("__tok31", __tok31)

(*
main.atxt: 5455(line=209, offs=4) -- 5470(line=209, offs=19)
*)
val __tok41 = comment("para")
val () = theAtextMap_insert_str ("__tok41", __tok41)

(*
main.atxt: 5697(line=219, offs=50) -- 5707(line=219, offs=60)
*)
val __tok43 = code("=>")
val () = theAtextMap_insert_str ("__tok43", __tok43)

(*
main.atxt: 5640(line=218, offs=2) -- 5842(line=222, offs=3)
*)
val __tok42 = para("\
Given a pattern pat and an expression exp, (pat #__tok43$ exp) is a
matching clause. The pattern pat and the expression exp are referred to as
the guard and the body of the matching clause.
")
val () = theAtextMap_insert_str ("__tok42", __tok42)

(*
main.atxt: 5963(line=226, offs=42) -- 5975(line=226, offs=54)
*)
val __tok45 = code("case")
val () = theAtextMap_insert_str ("__tok45", __tok45)

(*
main.atxt: 5982(line=227, offs=2) -- 5992(line=227, offs=12)
*)
val __tok46 = code("of")
val () = theAtextMap_insert_str ("__tok46", __tok46)

(*
main.atxt: 5845(line=224, offs=2) -- 6558(line=235, offs=3)
*)
val __tok44 = para("\
Given an expression exp0 and a sequence of matching clauses clseq, a
case-expression can be formed as such: (#__tok45$ exp0
#__tok46$ clseq). To evaluate the case-expression under a given
environment ENV0, we first evaluate exp0 under ENV0 to a value. If this
value does not match the guard of any clause in clseq, then the evaluation
of the case-expression aborts. Otherwise, we choose the first clause in
clseq such that the value matches its guard. Let ENV1 be the environment
that extends ENV0 with the bindings generated from this matching, and we
evaluate the body of the chosen clause under ENV1. The value obtained
from this evaluation is the value of the case-expression being evaluated.
")
val () = theAtextMap_insert_str ("__tok44", __tok44)

(*
main.atxt: 6883(line=246, offs=25) -- 6895(line=246, offs=37)
*)
val __tok48 = code("wday")
val () = theAtextMap_insert_str ("__tok48", __tok48)

(*
main.atxt: 6899(line=248, offs=2) -- 7072(line=258, offs=3)
*)
val __tok49 = atscode("\
datatype wday =
  | Monday of ()
  | Tuesday of ()
  | Wednesday of ()
  | Thursday of ()
  | Friday of ()
  | Saturday of ()
  | Sunday of ()
// end of [wday]
")
val () = theAtextMap_insert_str ("__tok49", __tok49)

(*
main.atxt: 7193(line=261, offs=55) -- 7207(line=261, offs=69)
*)
val __tok50 = code("Monday")
val () = theAtextMap_insert_str ("__tok50", __tok50)

(*
main.atxt: 7217(line=262, offs=10) -- 7231(line=262, offs=24)
*)
val __tok51 = code("Sunday")
val () = theAtextMap_insert_str ("__tok51", __tok51)

(*
main.atxt: 7280(line=263, offs=2) -- 7292(line=263, offs=14)
*)
val __tok52 = code("wday")
val () = theAtextMap_insert_str ("__tok52", __tok52)

(*
main.atxt: 7309(line=263, offs=31) -- 7325(line=263, offs=47)
*)
val __tok53 = code("Monday()")
val () = theAtextMap_insert_str ("__tok53", __tok53)

(*
main.atxt: 7350(line=264, offs=7) -- 7362(line=264, offs=19)
*)
val __tok54 = code("wday")
val () = theAtextMap_insert_str ("__tok54", __tok54)

(*
main.atxt: 7458(line=265, offs=45) -- 7472(line=265, offs=59)
*)
val __tok55 = code("Monday")
val () = theAtextMap_insert_str ("__tok55", __tok55)

(*
main.atxt: 7478(line=266, offs=2) -- 7494(line=266, offs=18)
*)
val __tok56 = code("Monday()")
val () = theAtextMap_insert_str ("__tok56", __tok56)

(*
main.atxt: 7554(line=267, offs=7) -- 7569(line=267, offs=22)
*)
val __tok57 = code("Tuesday")
val () = theAtextMap_insert_str ("__tok57", __tok57)

(*
main.atxt: 7589(line=267, offs=42) -- 7605(line=267, offs=58)
*)
val __tok58 = code("Monday+1")
val () = theAtextMap_insert_str ("__tok58", __tok58)

(*
main.atxt: 6716(line=243, offs=2) -- 7609(line=268, offs=3)
*)
val __tok47 = para("\
The simplest form of datatypes is for enumerating a finite number
of constants. For instance, the following concrete syntax introduces
a datatype of the name #__tok48$:

#__tok49$

where the first bar symbol (|) is optional.  There are 7 nullary
constructors introduced in the datatype declaration: #__tok50$
through #__tok51$, which are for constructing values of the type
#__tok52$. For instance, #__tok53$ is a value of the
type #__tok54$. Given a nullary constructor C, we can write C for
C() as a value. For instance, we can write #__tok55$ for
#__tok56$. However, one should <emphasis>not</emphasis> assume
that #__tok57$ is something like #__tok58$.
")
val () = theAtextMap_insert_str ("__tok47", __tok47)

(*
main.atxt: 7610(line=268, offs=4) -- 7625(line=268, offs=19)
*)
val __tok59 = comment("para")
val () = theAtextMap_insert_str ("__tok59", __tok59)

(*
main.atxt: 7723(line=272, offs=28) -- 7735(line=272, offs=40)
*)
val __tok61 = code("wday")
val () = theAtextMap_insert_str ("__tok61", __tok61)

(*
main.atxt: 7759(line=274, offs=2) -- 8050(line=285, offs=3)
*)
val __tok62 = atscode("\
fun isWeekday
  (x: wday): bool = case x of
  | Monday () => true // the bar (|) is optional for the first clause
  | Tuesday () => true
  | Wednesday () => true
  | Thursday () => true
  | Friday () => true
  | Saturday () => false
  | Sunday () => false
// end of [isWeekday]
")
val () = theAtextMap_insert_str ("__tok62", __tok62)

(*
main.atxt: 8225(line=289, offs=24) -- 8242(line=289, offs=41)
*)
val __tok63 = code("Monday ()")
val () = theAtextMap_insert_str ("__tok63", __tok63)

(*
main.atxt: 8258(line=290, offs=2) -- 8272(line=290, offs=16)
*)
val __tok64 = code("Monday")
val () = theAtextMap_insert_str ("__tok64", __tok64)

(*
main.atxt: 8302(line=290, offs=46) -- 8319(line=290, offs=63)
*)
val __tok65 = code("isWeekday")
val () = theAtextMap_insert_str ("__tok65", __tok65)

(*
main.atxt: 8472(line=293, offs=5) -- 8486(line=293, offs=19)
*)
val __tok66 = code("Monday")
val () = theAtextMap_insert_str ("__tok66", __tok66)

(*
main.atxt: 8597(line=295, offs=2) -- 8614(line=295, offs=19)
*)
val __tok67 = code("isWeekday")
val () = theAtextMap_insert_str ("__tok67", __tok67)

(*
main.atxt: 8638(line=297, offs=2) -- 8775(line=302, offs=3)
*)
val __tok68 = atscode("\
fun isWeekday
  (x: wday): bool = case x of
  | Saturday () => false | Sunday () => false | _ => true
// end of [isWeekday]
")
val () = theAtextMap_insert_str ("__tok68", __tok68)

(*
main.atxt: 8886(line=305, offs=35) -- 8898(line=305, offs=47)
*)
val __tok69 = code("wday")
val () = theAtextMap_insert_str ("__tok69", __tok69)

(*
main.atxt: 8925(line=306, offs=2) -- 8944(line=306, offs=21)
*)
val __tok70 = code("Saturday ()")
val () = theAtextMap_insert_str ("__tok70", __tok70)

(*
main.atxt: 8950(line=306, offs=27) -- 8967(line=306, offs=44)
*)
val __tok71 = code("Sunday ()")
val () = theAtextMap_insert_str ("__tok71", __tok71)

(*
main.atxt: 8996(line=307, offs=5) -- 9013(line=307, offs=22)
*)
val __tok72 = code("Monday ()")
val () = theAtextMap_insert_str ("__tok72", __tok72)

(*
main.atxt: 9017(line=307, offs=26) -- 9035(line=307, offs=44)
*)
val __tok73 = code("Tuesday ()")
val () = theAtextMap_insert_str ("__tok73", __tok73)

(*
main.atxt: 9039(line=307, offs=48) -- 9059(line=308, offs=5)
*)
val __tok74 = code("Wednesday
()")
val () = theAtextMap_insert_str ("__tok74", __tok74)

(*
main.atxt: 9063(line=308, offs=9) -- 9082(line=308, offs=28)
*)
val __tok75 = code("Thursday ()")
val () = theAtextMap_insert_str ("__tok75", __tok75)

(*
main.atxt: 9088(line=308, offs=34) -- 9105(line=308, offs=51)
*)
val __tok76 = code("Friday ()")
val () = theAtextMap_insert_str ("__tok76", __tok76)

(*
main.atxt: 7628(line=270, offs=2) -- 9109(line=309, offs=3)
*)
val __tok60 = para("\
The following code implements a function that tests whether
a given value of the type #__tok61$ is a weekday or not:

#__tok62$

Given a unary constructor C, C() is a pattern that can only match the value
C(). Note that C() <emphasis>cannot</emphasis> be written as C when it is
used as a pattern. If #__tok63$ is written as
#__tok64$ in the body of the function #__tok65$,
then an error message is to be reported during typechecking, indicating
that all the clauses after the first one are redundant. This is simply due
to #__tok66$ being treated as a variable pattern, which is
matched by any value. A likely more sensible implementation of
#__tok67$ is given as follows:

#__tok68$

This implementation works because pattern-matching is done sequentially at
run-time: If a value of the type #__tok69$ does not match either of
#__tok70$ and #__tok71$, then it must match one
of #__tok72$ , #__tok73$ , #__tok74$ , #__tok75$ and #__tok76$.
")
val () = theAtextMap_insert_str ("__tok60", __tok60)

(*
main.atxt: 9110(line=309, offs=4) -- 9125(line=309, offs=19)
*)
val __tok77 = comment("para")
val () = theAtextMap_insert_str ("__tok77", __tok77)

(*
main.atxt: 9447(line=321, offs=34) -- 9462(line=321, offs=49)
*)
val __tok79 = code("charlst")
val () = theAtextMap_insert_str ("__tok79", __tok79)

(*
main.atxt: 9479(line=323, offs=2) -- 9587(line=327, offs=3)
*)
val __tok80 = atscode("\
datatype charlst =
  | charlst_nil of () | charlst_cons of (char, charlst)
// end of [charlst]
")
val () = theAtextMap_insert_str ("__tok80", __tok80)

(*
main.atxt: 9642(line=329, offs=54) -- 9657(line=329, offs=69)
*)
val __tok81 = code("charlst")
val () = theAtextMap_insert_str ("__tok81", __tok81)

(*
main.atxt: 9676(line=330, offs=18) -- 9696(line=330, offs=38)
*)
val __tok82 = code("charlst_cons")
val () = theAtextMap_insert_str ("__tok82", __tok82)

(*
main.atxt: 9724(line=331, offs=2) -- 9739(line=331, offs=17)
*)
val __tok83 = code("charlst")
val () = theAtextMap_insert_str ("__tok83", __tok83)

(*
main.atxt: 9838(line=334, offs=2) -- 9914(line=336, offs=3)
*)
val __tok84 = atscode("\
char_cons ('a', char_cons ('b', char_cons ('c', char_nil ())))
")
val () = theAtextMap_insert_str ("__tok84", __tok84)

(*
main.atxt: 9942(line=338, offs=27) -- 9964(line=338, offs=49)
*)
val __tok85 = code("charlst_length")
val () = theAtextMap_insert_str ("__tok85", __tok85)

(*
main.atxt: 10027(line=341, offs=2) -- 10196(line=347, offs=3)
*)
val __tok86 = atscode("\
fun charlst_length (cs: charlst): int =
  case cs of
  | charlst_cons (_, cs) => 1 + charlst_length (cs)
  | charlst_nil () => 0
// end of [charlst_length]
")
val () = theAtextMap_insert_str ("__tok86", __tok86)

(*
main.atxt: 10381(line=351, offs=39) -- 10403(line=351, offs=61)
*)
val __tok87 = code("charlst_length")
val () = theAtextMap_insert_str ("__tok87", __tok87)

(*
main.atxt: 10430(line=354, offs=2) -- 10675(line=363, offs=3)
*)
val __tok88 = atscode("\
fun charlst_length
  (cs: charlst): int = let
  fun loop (cs: charlst, n: int): int = case cs of
    | charlst_cons (_, cs) => loop (cs, n+1) | charlst_nil () => n
  // end of [loop]
in
  loop (cs, 0)
end // end of [charlst_length]
")
val () = theAtextMap_insert_str ("__tok88", __tok88)

(*
main.atxt: 9264(line=318, offs=2) -- 10999(line=371, offs=3)
*)
val __tok78 = para("\
A recursive datatype is one such that its associated constructors
may form values by applying to values of the datatype itself. For instance,
the following declared datatype #__tok79$ is recursive:

#__tok80$

When applied to a character and a value of the type #__tok81$,
the constructor #__tok82$ forms a value of the type
#__tok83$. As an example, the following value represents a
character list consisting of 'a', 'b' and 'c':

#__tok84$

We can define a function #__tok85$ as follows to compute
the length of a given character list:

#__tok86$

Note that this implementation is recursive but not tail-recursive. By
relying on the commutativity and associativity of integer addition, we can
give the following implementation of #__tok87$ that is
tail-recursive:

#__tok88$

Note that the naming convention I follow closely in this book (and
elsewhere) mandates that only a tail-recursive function be given a name
indicative of its being a loop. A non-tail-recursive function is not called
a loop because it cannot be translated directly to a loop in an imperative
programming language like C.

")
val () = theAtextMap_insert_str ("__tok78", __tok78)

(*
main.atxt: 11000(line=371, offs=4) -- 11015(line=371, offs=19)
*)
val __tok89 = comment("para")
val () = theAtextMap_insert_str ("__tok89", __tok89)

(*
main.atxt: 11479(line=385, offs=3) -- 11491(line=385, offs=15)
*)
val __tok91 = code("case")
val () = theAtextMap_insert_str ("__tok91", __tok91)

(*
main.atxt: 11498(line=385, offs=22) -- 11508(line=385, offs=32)
*)
val __tok92 = code("of")
val () = theAtextMap_insert_str ("__tok92", __tok92)

(*
main.atxt: 11182(line=380, offs=2) -- 11739(line=389, offs=3)
*)
val __tok90 = para("\
Given a type T and a set of patterns, if for any given value of the
type T there is always at least one pattern in the set such that the value
matches the pattern, then pattern-matching values of the type T against the
set of patterns is exhaustive.  Given a case-expression of the form
(#__tok91$ exp0 #__tok92$ clseq), where exp0 is assumed to be
of some type T, if pattern-matching values of the type T against the guards
of the matching clauses in clseq is exhaustive, then the case-expression is
said to be pattern-matching-exhaustive.
")
val () = theAtextMap_insert_str ("__tok90", __tok90)

(*
main.atxt: 11740(line=389, offs=4) -- 11755(line=389, offs=19)
*)
val __tok93 = comment("para")
val () = theAtextMap_insert_str ("__tok93", __tok93)

(*
main.atxt: 11870(line=395, offs=2) -- 12050(line=401, offs=3)
*)
val __tok95 = atscode("\
fun charlst_last
  (cs: charlst): char = case cs of
  | charlst_cons (c, charlst_nil ()) => c
  | charlst_cons (_, cs1) => charlst_last (cs1)
// end of [charlst_last]
")
val () = theAtextMap_insert_str ("__tok95", __tok95)

(*
main.atxt: 12065(line=403, offs=14) -- 12085(line=403, offs=34)
*)
val __tok96 = code("charlst_last")
val () = theAtextMap_insert_str ("__tok96", __tok96)

(*
main.atxt: 12154(line=404, offs=34) -- 12164(line=404, offs=44)
*)
val __tok97 = code("cs")
val () = theAtextMap_insert_str ("__tok97", __tok97)

(*
main.atxt: 12188(line=405, offs=2) -- 12209(line=405, offs=23)
*)
val __tok98 = code("charlst_nil()")
val () = theAtextMap_insert_str ("__tok98", __tok98)

(*
main.atxt: 12520(line=409, offs=46) -- 12532(line=409, offs=58)
*)
val __tok99 = code("case")
val () = theAtextMap_insert_str ("__tok99", __tok99)

(*
main.atxt: 12558(line=410, offs=16) -- 12571(line=410, offs=29)
*)
val __tok100 = code("case+")
val () = theAtextMap_insert_str ("__tok100", __tok100)

(*
main.atxt: 12644(line=411, offs=31) -- 12656(line=411, offs=43)
*)
val __tok101 = code("case")
val () = theAtextMap_insert_str ("__tok101", __tok101)

(*
main.atxt: 12682(line=412, offs=2) -- 12695(line=412, offs=15)
*)
val __tok102 = code("case-")
val () = theAtextMap_insert_str ("__tok102", __tok102)

(*
main.atxt: 12718(line=412, offs=38) -- 12731(line=412, offs=51)
*)
val __tok103 = code("case+")
val () = theAtextMap_insert_str ("__tok103", __tok103)

(*
main.atxt: 11758(line=391, offs=2) -- 12754(line=413, offs=3)
*)
val __tok94 = para("\
The following code implements a function that finds the last character
in a non-empty character list:

#__tok95$

The body of #__tok96$ is a case-expression, which is not
pattern-matching-exhaustive: If #__tok97$ is bound to the value
#__tok98$, that is, the empty character list, than none
of the matching clauses in the case-expression can be chosen. When the code
is typechecked by atsopt, a warning message is issued to indicate the
case-expression being non-pattern-matching-exhaustive. If the programmer
wants an error message instead, the keyword #__tok99$ should be
replaced with #__tok100$.  If the programmer wants to suppress the
warning message, the keyword #__tok101$ should be replaced with
#__tok102$. I myself mostly use #__tok103$ when coding in ATS.
")
val () = theAtextMap_insert_str ("__tok94", __tok94)

(*
main.atxt: 12755(line=413, offs=4) -- 12770(line=413, offs=19)
*)
val __tok104 = comment("para")
val () = theAtextMap_insert_str ("__tok104", __tok104)

(*
main.atxt: 12795(line=416, offs=15) -- 12815(line=416, offs=35)
*)
val __tok106 = code("charlst_last")
val () = theAtextMap_insert_str ("__tok106", __tok106)

(*
main.atxt: 12854(line=418, offs=2) -- 13080(line=425, offs=3)
*)
val __tok107 = atscode("\
fun charlst_last
  (cs: charlst): char = case cs of
  | charlst_cons (c, cs1) => (case+ cs1 of
      charlst_nil () => c | charlst_cons _ => charlst_last (cs1)
    ) // end of [char_cons]
// end of [charlst_last]
")
val () = theAtextMap_insert_str ("__tok107", __tok107)

(*
main.atxt: 13214(line=429, offs=2) -- 13236(line=429, offs=24)
*)
val __tok108 = code("charlst_cons _")
val () = theAtextMap_insert_str ("__tok108", __tok108)

(*
main.atxt: 13262(line=429, offs=50) -- 13289(line=430, offs=5)
*)
val __tok109 = code("charlst_cons (_,
_)")
val () = theAtextMap_insert_str ("__tok109", __tok109)

(*
main.atxt: 13463(line=432, offs=44) -- 13486(line=432, offs=67)
*)
val __tok110 = code("charlst_nil () ")
val () = theAtextMap_insert_str ("__tok110", __tok110)

(*
main.atxt: 13511(line=433, offs=21) -- 13532(line=433, offs=42)
*)
val __tok111 = code("charlst_nil _")
val () = theAtextMap_insert_str ("__tok111", __tok111)

(*
main.atxt: 12773(line=415, offs=2) -- 13536(line=434, offs=3)
*)
val __tok105 = para("\
The function #__tok106$ can also be implemented as follows:

#__tok107$

In this implementation, the outer case-expression is not
pattern-matching-exhaustive while the inner one is. Note that the pattern
#__tok108$ is just a shorthand for #__tok109$. In general, a pattern of the from (C _), where C is a
constructor, can be matched by any value that is constructed by applying C
to some values. For instance, the pattern #__tok110$ can
also be written as #__tok111$.
")
val () = theAtextMap_insert_str ("__tok105", __tok105)

(*
main.atxt: 13537(line=434, offs=4) -- 13552(line=434, offs=19)
*)
val __tok112 = comment("para")
val () = theAtextMap_insert_str ("__tok112", __tok112)

(*
main.atxt: 13680(line=438, offs=55) -- 13692(line=438, offs=67)
*)
val __tok114 = code("case")
val () = theAtextMap_insert_str ("__tok114", __tok114)

(*
main.atxt: 13699(line=439, offs=2) -- 13709(line=439, offs=12)
*)
val __tok115 = code("of")
val () = theAtextMap_insert_str ("__tok115", __tok115)

(*
main.atxt: 13715(line=439, offs=18) -- 13725(line=439, offs=28)
*)
val __tok116 = code("=>")
val () = theAtextMap_insert_str ("__tok116", __tok116)

(*
main.atxt: 13800(line=440, offs=40) -- 13811(line=440, offs=51)
*)
val __tok117 = code("let")
val () = theAtextMap_insert_str ("__tok117", __tok117)

(*
main.atxt: 13813(line=440, offs=53) -- 13824(line=440, offs=64)
*)
val __tok118 = code("val")
val () = theAtextMap_insert_str ("__tok118", __tok118)

(*
main.atxt: 13830(line=441, offs=2) -- 13839(line=441, offs=11)
*)
val __tok119 = code("=")
val () = theAtextMap_insert_str ("__tok119", __tok119)

(*
main.atxt: 13846(line=441, offs=18) -- 13856(line=441, offs=28)
*)
val __tok120 = code("in")
val () = theAtextMap_insert_str ("__tok120", __tok120)

(*
main.atxt: 13862(line=441, offs=34) -- 13873(line=441, offs=45)
*)
val __tok121 = code("end")
val () = theAtextMap_insert_str ("__tok121", __tok121)

(*
main.atxt: 13938(line=442, offs=46) -- 13958(line=442, offs=66)
*)
val __tok122 = code("charlst_last")
val () = theAtextMap_insert_str ("__tok122", __tok122)

(*
main.atxt: 13973(line=445, offs=2) -- 14172(line=451, offs=3)
*)
val __tok123 = atscode("\
fun charlst_last
  (cs: charlst): char = let
  val charlst_cons (c, cs1) = cs in case+ cs1 of
  | charlst_nil () => c | charlst_cons _ => charlst_last (cs1)
end // end of [charlst_last]
")
val () = theAtextMap_insert_str ("__tok123", __tok123)

(*
main.atxt: 14387(line=456, offs=23) -- 14398(line=456, offs=34)
*)
val __tok124 = code("val")
val () = theAtextMap_insert_str ("__tok124", __tok124)

(*
main.atxt: 14424(line=457, offs=2) -- 14436(line=457, offs=14)
*)
val __tok125 = code("val+")
val () = theAtextMap_insert_str ("__tok125", __tok125)

(*
main.atxt: 14509(line=458, offs=23) -- 14520(line=458, offs=34)
*)
val __tok126 = code("val")
val () = theAtextMap_insert_str ("__tok126", __tok126)

(*
main.atxt: 14546(line=459, offs=2) -- 14558(line=459, offs=14)
*)
val __tok127 = code("val-")
val () = theAtextMap_insert_str ("__tok127", __tok127)

(*
main.atxt: 13555(line=436, offs=2) -- 14562(line=460, offs=3)
*)
val __tok113 = para("\
Suppose we have a case-expression containing only one matching
clause, that is, the case-expression is of the form (#__tok114$ exp0
#__tok115$ pat #__tok116$ exp).  Then we can also write this
case-expression as a let-expression: (#__tok117$ #__tok118$ pat
#__tok119$ exp0 #__tok120$ exp #__tok121$). For instance, we
give another implementation of the function #__tok122$ as
follows:

#__tok123$

When this implementation is typechecked by atsopt, a warning message is
issued to indicate the val-declaration being
non-pattern-matching-exhaustive. If the programmer wants an error message
instead, the keyword #__tok124$ should be replaced with
#__tok125$.  If the programmer wants to suppress the warning
message, the keyword #__tok126$ should be replaced with
#__tok127$.
")
val () = theAtextMap_insert_str ("__tok113", __tok113)

(*
main.atxt: 14563(line=460, offs=4) -- 14578(line=460, offs=19)
*)
val __tok128 = comment("para")
val () = theAtextMap_insert_str ("__tok128", __tok128)

(*
main.atxt: 14627(line=463, offs=39) -- 14646(line=463, offs=58)
*)
val __tok130 = code("charlst_nil")
val () = theAtextMap_insert_str ("__tok130", __tok130)

(*
main.atxt: 14652(line=464, offs=2) -- 14672(line=464, offs=22)
*)
val __tok131 = code("charlst_cons")
val () = theAtextMap_insert_str ("__tok131", __tok131)

(*
main.atxt: 14701(line=464, offs=51) -- 14716(line=464, offs=66)
*)
val __tok132 = code("charlst")
val () = theAtextMap_insert_str ("__tok132", __tok132)

(*
main.atxt: 14784(line=466, offs=2) -- 14804(line=466, offs=22)
*)
val __tok133 = code("charlst_last")
val () = theAtextMap_insert_str ("__tok133", __tok133)

(*
main.atxt: 14581(line=462, offs=2) -- 15089(line=471, offs=3)
*)
val __tok129 = para("\
As values formed by the constructors #__tok130$ and
#__tok131$ are assigned the same type #__tok132$,
it is impossible to rely on typechecking to prevent the function
#__tok133$ from being applied to an empty character list.
This is a serious limitation.  With dependent types, which allow data to be
described much more precisely, we can ensure at the level of types that a
function finding the last element of a list can only be applied to a
non-empty list.
")
val () = theAtextMap_insert_str ("__tok129", __tok129)

(*
main.atxt: 15354(line=484, offs=2) -- 15366(line=484, offs=14)
*)
val __tok135 = code("IEXP")
val () = theAtextMap_insert_str ("__tok135", __tok135)

(*
main.atxt: 15381(line=486, offs=2) -- 15660(line=495, offs=3)
*)
val __tok136 = atscode("\
datatype IEXP =
  | IEXPnum of int // numeral
  | IEXPneg of (IEXP) // negative
  | IEXPadd of (IEXP, IEXP) // addition
  | IEXPsub of (IEXP, IEXP) // subtraction
  | IEXPmul of (IEXP, IEXP) // multiplication
  | IEXPdiv of (IEXP, IEXP) // division
// end of [IEXP]
")
val () = theAtextMap_insert_str ("__tok136", __tok136)

(*
main.atxt: 15711(line=497, offs=50) -- 15723(line=497, offs=62)
*)
val __tok137 = code("IEXP")
val () = theAtextMap_insert_str ("__tok137", __tok137)

(*
main.atxt: 15764(line=498, offs=31) -- 15776(line=498, offs=43)
*)
val __tok138 = code("IEXP")
val () = theAtextMap_insert_str ("__tok138", __tok138)

(*
main.atxt: 15921(line=502, offs=2) -- 16011(line=504, offs=3)
*)
val __tok139 = atscode("\
IEXPadd(IEXPneg(IEXPnum(1)), IEXPmul(IEXPsub(IEXPnum(2), IEXP(3)), IEXP(4)))
")
val () = theAtextMap_insert_str ("__tok139", __tok139)

(*
main.atxt: 16182(line=508, offs=29) -- 16199(line=508, offs=46)
*)
val __tok140 = code("eval_iexp")
val () = theAtextMap_insert_str ("__tok140", __tok140)

(*
main.atxt: 16318(line=512, offs=2) -- 16674(line=521, offs=3)
*)
val __tok141 = atscode("\
fun eval_iexp (e0: IEXP): int = case+ e0 of
  | IEXPnum n => n
  | IEXPneg (e) => ~eval_iexp (e)
  | IEXPadd (e1, e2) => eval_iexp (e1) + eval_iexp (e2)
  | IEXPsub (e1, e2) => eval_iexp (e1) - eval_iexp (e2)
  | IEXPmul (e1, e2) => eval_iexp (e1) * eval_iexp (e2)
  | IEXPdiv (e1, e2) => eval_iexp (e1) / eval_iexp (e1)
// end of [eval_iexp]
")
val () = theAtextMap_insert_str ("__tok141", __tok141)

(*
main.atxt: 15285(line=482, offs=2) -- 16677(line=522, offs=3)
*)
val __tok134 = para("\
For representing integer expressions, we declare a datatype
#__tok135$ as follows:

#__tok136$

The meaning of the constructors associated with #__tok137$ should be
obvious. A value of the type #__tok138$ is often referred to as an
abstract syntax tree. For instance, the abstract syntax tree for the
expression (~1+(2-3)*4) is the following one:

#__tok139$

Translating an integer expression written in some string form into an
abstract syntax tree is called parsing, which we will not do here. The
following defined function #__tok140$ takes the abstract syntax
tree of an integer expression and returns an integer that is the value of
the expression:

#__tok141$
")
val () = theAtextMap_insert_str ("__tok134", __tok134)

(*
main.atxt: 16678(line=522, offs=4) -- 16693(line=522, offs=19)
*)
val __tok142 = comment("para")
val () = theAtextMap_insert_str ("__tok142", __tok142)

(*
main.atxt: 17031(line=529, offs=52) -- 17043(line=529, offs=64)
*)
val __tok144 = code("BEXP")
val () = theAtextMap_insert_str ("__tok144", __tok144)

(*
main.atxt: 17096(line=530, offs=49) -- 17108(line=530, offs=61)
*)
val __tok145 = code("IEXP")
val () = theAtextMap_insert_str ("__tok145", __tok145)

(*
main.atxt: 17114(line=531, offs=2) -- 17126(line=531, offs=14)
*)
val __tok146 = code("BEXP")
val () = theAtextMap_insert_str ("__tok146", __tok146)

(*
main.atxt: 17207(line=534, offs=2) -- 18057(line=557, offs=3)
*)
val __tok147 = atscode("\
datatype IEXP =
  | IEXPcst of int // integer constants
  | IEXPneg of (IEXP) // negative
  | IEXPadd of (IEXP, IEXP) // addition
  | IEXPsub of (IEXP, IEXP) // subtraction
  | IEXPmul of (IEXP, IEXP) // multiplication
  | IEXPdiv of (IEXP, IEXP) // division
  | IEXPif of (BEXP(*test*), IEXP(*then*), IEXP(*else*))
// end of [IEXP]

and BEXP = // [and] for combining datatype declarations
  | BEXPcst of bool // boolean constants
  | BEXPneg of BEXP // negation
  | BEXPconj of (BEXP, BEXP) // conjunction
  | BEXPdisj of (BEXP, BEXP) // disjunction
  | BEXPeq of (IEXP, IEXP) // equal-to
  | BEXPneq of (IEXP, IEXP) // not-equal-to
  | BEXPlt of (IEXP, IEXP) // less-than
  | BEXPlte of (IEXP, IEXP) // less-than-equal-to
  | BEXPgt of (IEXP, IEXP) // greater-than
  | BEXPgte of (IEXP, IEXP) // greater-than-equal-to
// end of [BEXP]
")
val () = theAtextMap_insert_str ("__tok147", __tok147)

(*
main.atxt: 18181(line=560, offs=51) -- 18198(line=560, offs=68)
*)
val __tok148 = code("eval_iexp")
val () = theAtextMap_insert_str ("__tok148", __tok148)

(*
main.atxt: 18204(line=561, offs=2) -- 18221(line=561, offs=19)
*)
val __tok149 = code("eval_bexp")
val () = theAtextMap_insert_str ("__tok149", __tok149)

(*
main.atxt: 18335(line=564, offs=2) -- 19442(line=589, offs=3)
*)
val __tok150 = atscode("\
fun eval_iexp (e0: IEXP): int = case+ e0 of
  | IEXPcst n => n
  | IEXPneg (e) => ~eval_iexp (e)
  | IEXPadd (e1, e2) => eval_iexp (e1) + eval_iexp (e2)
  | IEXPsub (e1, e2) => eval_iexp (e1) - eval_iexp (e2)
  | IEXPmul (e1, e2) => eval_iexp (e1) * eval_iexp (e2)
  | IEXPdiv (e1, e2) => eval_iexp (e1) / eval_iexp (e1)
  | IEXPif (e_test, e_then, e_else) => let
      val b = eval_bexp (e_test) in eval_iexp (if b then e_then else e_else)
    end // end of [IEXPif]
// end of [eval_iexp]

and eval_bexp (e0: BEXP): bool = case+ e0 of
  | BEXPcst b => b
  | BEXPneg (e) => ~eval_bexp (e)
  | BEXPconj (e1, e2) => if eval_bexp (e1) then eval_bexp (e2) else false
  | BEXPdisj (e1, e2) => if eval_bexp (e1) then true else eval_bexp (e2)
  | BEXPeq (e1, e2) => eval_iexp (e1) = eval_iexp (e2)
  | BEXPneq (e1, e2) => eval_iexp (e1) <> eval_iexp (e2)
  | BEXPlt (e1, e2) => eval_iexp (e1) < eval_iexp (e2)
  | BEXPlte (e1, e2) => eval_iexp (e1) <= eval_iexp (e2)
  | BEXPgt (e1, e2) => eval_iexp (e1) > eval_iexp (e2)
  | BEXPgte (e1, e2) => eval_iexp (e1) >= eval_iexp (e2)
// end of [eval_bexp]
")
val () = theAtextMap_insert_str ("__tok150", __tok150)

(*
main.atxt: 16696(line=524, offs=2) -- 19445(line=590, offs=3)
*)
val __tok143 = para("\
Suppose we also allow the construct if-then-else to be use in
forming integer expressions. For instance, we may write an integer
expression like (if 1+2 <= 3*4 then 5+6 else 7-8). Note that the test (1+2
<= 3*4) is a boolean expression rather than an integer expression. This
indicates that we also need to declare a datatype #__tok144$ for
representing boolean expressions. Furthermore, #__tok145$ and
#__tok146$ should be defined mutually recursively, which is shown in
the following code:

#__tok147$

Evidently, we also need to evaluate boolean expressions when evaluating
integer expressions. The following two functions #__tok148$ and
#__tok149$ for evaluating integer and boolean expressions,
respectively, are defined mutually recursively as is expected:

#__tok150$
")
val () = theAtextMap_insert_str ("__tok143", __tok143)

(*
main.atxt: 19446(line=590, offs=4) -- 19461(line=590, offs=19)
*)
val __tok151 = comment("para")
val () = theAtextMap_insert_str ("__tok151", __tok151)

(*
main.atxt: 19464(line=592, offs=2) -- 19831(line=598, offs=3)
*)
val __tok152 = para("\
The integer and boolean expressions used in this example are all
constant expressions containing no variables. Therefore, there is no need
for an environment to evaluate them. I will present a more advanced example
elsewhere to demonstrate how an evaluator for a simple call-by-value
functional programming language like the core of ATS can be implemented.
")
val () = theAtextMap_insert_str ("__tok152", __tok152)

(*
main.atxt: 19930(line=604, offs=2) -- 19956(line=604, offs=28)
*)
val __tok153 = comment(" ****** ****** ")
val () = theAtextMap_insert_str ("__tok153", __tok153)

(*
main.atxt: 19959(line=606, offs=2) -- 19990(line=606, offs=33)
*)
val __tok154 = comment(" end of [main.atxt] ")
val () = theAtextMap_insert_str ("__tok154", __tok154)

(*
main.atxt: 19992(line=608, offs=1) -- 20061(line=610, offs=3)
*)

implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")

