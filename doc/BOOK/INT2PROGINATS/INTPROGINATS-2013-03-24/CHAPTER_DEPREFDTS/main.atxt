%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include "./../proginatsatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
<chapter id="datatype_refinement">
<title>Datatype Refinement</title>

#para("\
The datatype mechanism in ATS is adopted from ML directly, and it is
really a signatory feature in functional programming. However, the
datatypes we have seen so far are largely imprecise when employed to
classify values. For instance, given a type T, the type
#code("list0")(T) is for values representing both empty and non-empty
lists consisting of elements of the type T. Therefore, empty and non-empty
lists cannot be distinguished at the level of types. This limitation
severely diminishes the effectiveness of datatypes of ML-style in capturing
program invariants. In ATS, datatypes of ML-style can be refined into
dependent datatypes of DML-style, where DML refers to the programming
language Dependent ML, the immediate precursor of ATS. With such
refinement, datatypes can classify values with greatly enhanced precision.
")#comment("para")

#para("\

The code employed for illustration in this chapter plus some
additional code for testing is available
#mycodelink("CHAPTER_DEPREFDTS/", "on-line").

")

<sect1 id="dependent_datatypes">

<title>
Dependent Datatypes
</title>

#para("\
The syntax for declaring dependent datatypes is mostly similar to
the syntax for declaring non-dependent datatypes: For instance, the
dependent datatype #code("list") in ATS is declared as follows:

#atscode("\
datatype list (t@ype+, int) =
  | {a:t@ype} list_nil (a, 0) of () // [of ()] is optional
  | {a:t@ype} {n:nat} list_cons (a, n+1) of (a, list (a, n))
")

More precisely, #code("list") is declared as a type constructor of the
sort <emphasis>(t@ype, int) -> type</emphasis>, which means that
#code("list") takes an unboxed type and a static integer to form a
boxed type. The keyword #code("t@ype+") indicates that
#code("list") is covariant at its first parameter (of the sort
<emphasis>t@ype</emphasis>), that is, #code("list(T1, I)") is
considered a subtype of #code("list(T2, I)") if T1 is a subtype of T2.
There is also the keyword #code("t@ype-") for indicating the declared
type constructor being contravariant at a parameter, but it is rarely used
in practice.  Keywords like #code("type+") and #code("type-") are
interpreted similarly.
")#comment("para")

#para("\
There two data (or value) constructors #code("list_nil") and
#code("list_cons") associated with #code("list"), which are
declared to be of the following types:

#atscode("\
list_nil : {a:t@ype} () -> list(a, 0)
list_cons : {a:t@ype} {n:nat} (a, list(a, n)) -> list(a, n+1)
")

Given a type T and a static integer I, the type #code("list")(T, I) is
for values representing lists of length I in which each element is of the
type T. Hence, the types of #code("list_nil") and
#code("list_cons") mean that #code("list_nil") forms a list of
length 0 and #code("list_cons") forms a list of length n+1 if applied
to an element and a list of length n.  Note that it is also possible to
declare #code("list") as follows in a more concise style:

#atscode("\
datatype list (a:t@ype+, int) =
  | list_nil (a, 0) of () // [of ()] is optional
  | {n:nat} list_cons (a, n+1) of (a, list (a, n))
")

The use of #code("a:t@ype+") (instead of #code("t@ype+"))
introduces implicitly a universal quantifier over #code("a") for the
type assigned to each data constructor associated with the declared type
constructor #code("list").
")#comment("para")

#para("\
As an example of programming with dependent datatypes, the following code
implements a function template for computing the length of a given list:

#atscode("\
fun{a:t@ype}
list_length {n:nat} .<n>.
  // .<n>. is a termination metric
  (xs: list (a, n)): int (n) = case+ xs of
  | list_cons (_, xs1) => 1 + list_length (xs1)
  | list_nil () => 0
// end of [list_length]
")

The type assigned to the function #code("list_length") indicates that
the function takes a list of length n for any natural number n and returns
an integer of value n. In addition, the function is verified to be
terminating. Therefore, #code("list_length") is guaranteed to implement
the function that computes the length of a given list. I now briefly
explain how typechecking can be performed on the definition of
#code("list_length"). Let us first see that the the following clause
typechecks:

#atscode("\
  | list_cons (_, xs1) => 1 + list_length (xs1)
")

What we need to verify is that the expression on the righthand side of the
symbol #code("=>") can be assigned the type #code("int(n)") under
the assumption that #code("xs") matches the pattern on the lefthand
side of the symbol #code("=>").  Let us assume that #code("xs1") is
of the type #code("list(a, n1)") for some natural number
#code("n1"), and this assumption implies that the pattern
#code("list_cons(_, xs1)") is of the type #code("list(a, n1+1)").
Clearly, matching #code("xs") against the pattern #code("list_cons(_,
xs1)") generates a condition #code("n=n1+1").  It is also clear
that #code("list_length(xs1)") is of the type #code("int(n1)") and
thus #code("1 + list_length(xs1)") is of the type
#code("int(1+n1)"). As the condition #code("n=n1+1") implies
#code("n=1+n1"), #code("1 + list_length(xs1)") can be given the
type #code("int(n)"). So this clause typechecks.  Note that matching
#code("xs") against the pattern #code("list_nil()") generates the
assumption n=0, which implies that #code("0") is of the type
#code("int(n)"). Therefore, the following clause typechecks:
")

#atscode("\
  | list_nil () => 0
")

#para("\

Given that the two clauses typecheck properly, the case-expression
containing them can be assigned the type #code("int(n)"). Therefore,
the definition of #code("list_length") typechecks.

")#comment("para")

#para('\

As the recursive call in the body of the above defined function
#code("list_length") is not a tail-call, the function may not be able
to handle a long list (e.g., one that contains 1 million elements).  The
following code gives another implementation for computing the length of a
given list:

')

#atscode('\
fun{a:t@ype}
list_length {n:nat} .<>.
  (xs: list (a, n)): int (n) = let
  // loop: {i,j:nat} (list (a, i), int (j)) -> int (i+j)
  fun loop {i,j:nat} .<i>.
    // .<i>. is a termination metric
    (xs: list (a, i), j: int j): int (i+j) = case+ xs of
    | list_cons (_, xs1) => loop (xs1, j+1) | list_nil () => j
  // end of [loop]
in
  loop (xs, 0)
end // end of [list_length]
')

#para('\

This time, #code("list_length") is based on a tail-recursive function
#code("loop") and thus can handle lists of any length in constant stack
space. Note that the type assigned to #code("loop") indicates that
#code("loop") takes a list of length i and an integer of value j for
some natural numbers i and j and returns an integer of value i+j. Also,
#code("loop") is verified to be terminating.

')#comment("para")

#para('\

There is also a dependent datatype #code("option") in ATS that corresponds to
#code("option0"):

')

#atscode('\
datatype
option (a:t@ype+, bool) =
  | Some (a, true) of a | None (a, false) of ()
// end of [option]
')

#para('\

As an example, the following function template #code("list_last") tries to
find the last element in a given list:

')

#atscode('\
fn{a:t@ype}
list_last
  {n:nat} (
  xs: list (a, n)
) : option (a, n > 0) = let
  fun loop {n:pos} .<n>.
    (xs: list (a, n)): a = let
    val+ list_cons (_, xs1) = xs
  in
    case+ xs1 of
    | list_cons _ => loop (xs1)
    | list_nil () => let
        val+ list_cons (x, _) = xs in x
      end // end of [list_nil]
  end // end of [loop]
in
  case+ xs of
  | list_cons _ => Some (loop (xs)) | list_nil () => None ()
end // end of [list_last]
')

#para('\

The inner function #code("loop") is evidently tail-recursive and it is
verified to be terminating.

')

#para('\

After a programmer becomes familar with #code("list") and #code("option"),
there is little incentive for him or her to use #code("list0") and
#code("option0") anymore. Internally, values of #code("list") and
#code("list0") have exactly the same representation and there are cast
functions of zero run-time cost in ATS for translating between values of
#code("list") and #code("list0"). The same applies to values of #code("option")
and #code("option0") as well.

')

</sect1><!--id="dependent_datatypes"-->

<!-- ****** ****** *-->

<sect1 id="example_function_templates_on_lists_redux">

<title>
Example: Function Templates on Lists (Redux)
</title>

#para("\

I have presented previously implementation of some commonly used function
templates on lists formed with the constructors #code("list0_nil") and
#code("list0_cons"). This time, I present as follows implementation of the
corresponding function templates on lists formed with the constructors
#code("list_nil") and #code("list_cons"), which make it possible to assign
more accurate types to these templates.

")

#para("\
Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAPTER_DEPREFDTS/listfun.dats", "on-line").
")

<sect2 id="list_append">
<title>
Appending: #code("list_append")
</title>

#para("\
Given two lists xs and ys of the types #code("list")(T, I1) and
#code("list")(T, I2) for some type T and integers I1 and I2,
#code("list_append")(xs, ys) returns a list of the type
#code("list")(T, I1+I2) that is the concatenation of xs and ys:

#atscode("\
fun{a:t@ype}
list_append
  {m,n:nat} .<m>. (
  xs: list (a, m), ys: list (a, n)
) : list (a, m+n) = case+ xs of
  | list_cons (x, xs) => list_cons (x, list_append (xs, ys))
  | list_nil () => ys
// end of [list_append]
")

Clearly, this implementation of #code("list_append") is not tail-recursive.
")#comment("para")

</sect2><!--id="list_append"-->

<sect2 id="list_reverse_append">
<title>
Reverse Appending: #code("list_reverse_append")
</title>

#para("\
Given two lists xs and ys of the type #code("list")(T, I1) and
#code("list")(T, I2) for some type T and integers I1 and I2,
#code("list_reverse_append")(xs, ys) returns a list of the type
#code("list")(T, I1+I2) that is the concatenation of the reverse of xs
and ys:

#atscode("\
fun{a:t@ype}
list_reverse_append
  {m,n:nat} .<m>. (
  xs: list (a, m), ys: list (a, n)
) : list (a, m+n) = case+ xs of
  | list_cons (x, xs) =>
      list_reverse_append (xs, list_cons (x, ys))
  | list_nil () => ys
// end of [list_reverse_append]
")

Clearly, this implementation of #code("list_reverse_append") is
tail-recursive.
")#comment("para")

</sect2><!--id="list_reverse_append"-->

<sect2 id="list_reverse">
<title>
Reversing: #code("list_reverse")
</title>

#para("\
Given a list xs, #code("list_reverse")(xs) returns the reverse
of xs, which is of the same length as xs:

#atscode("\
fun{a:t@ype}
list_reverse {n:nat} .<>. // defined non-recursively
  (xs: list (a, n)): list (a, n) = list_reverse_append (xs, list_nil)
// end of [list_reverse]
")
")#comment("para")

</sect2><!--id="list_reverse"-->

<sect2 id="list_map">
<title>
Mapping: #code("list_map")
</title>

#para("\
Given a list xs of the type #code("list")(T1, I) for some type
T1 and integer I and a closure function f of the type T1 -&lt;cloref1&gt;
T2 for some T2, #code("list_map")(xs) returns a list ys of the type
#code("list")(T2, I):

#atscode("\
fun{a:t@ype}{b:t@ype}
list_map {n:nat} .<n>. (
  xs: list (a, n), f: a -<cloref1> b
) : list (b, n) = case+ xs of
  | list_cons (x, xs) => list_cons (f x, list_map (xs, f))
  | list_nil () => list_nil ()
// end of [list_map]
")

Each element y in ys equals f(x), where x is the corresponding element in
xs.  Clearly, this implementation of #code("list_map") is not
tail-recursive.
")#comment("para")

</sect2><!--id="list_map"-->

<sect2 id="list_zip">
<title>
Zipping: #code("list_zip")
</title>

#para("\
Given two lists xs and ys of the types #code("list")(T1, I) and
#code("list")(T2, I) for some types T1 and T2 and integer I,
respectively, #code("list_zip")(xs, ys) returns a list zs of the type
#code("list")((T1, T2), I):

#atscode("\
fun{a,b:t@ype}
list_zip {n:nat} .<n>. (
  xs: list (a, n), ys: list (b, n)
) : list ((a, b), n) = case+ (xs, ys) of
  | (list_cons (x, xs),
     list_cons (y, ys)) => list_cons ((x, y), list_zip (xs, ys))
  | (list_nil (), list_nil ()) => list_nil ()
// end of [list_zip]
")

Each element z in zs equals the pair (x, y), where x and y are the
corresponding elements in xs and ys, respectively.  Clearly, this
implementation of #code("list_zip") is not tail-recursive.
")#comment("para")

</sect2><!--id="list_zip"-->

<sect2 id="list_zipwith">
<title>
Zipping with: #code("list_zipwith")
</title>

#para("\
Given two lists xs and ys of the types #code("list")(T1, I) and
#code("list")(T2, I) for some types T1 and T2 and integer I,
respectively, and a closure function f of the type (T1, T2)
-&lt;cloref1&gt; T3 for some type T3, #code("list_zipwith")(xs, ys, f)
returns a list zs of the type #code("list")(T3, I):

#atscode("\
fun{a,b:t@ype}{c:t@ype}
list_zipwith
  {n:nat} .<n>. (
  xs: list (a, n)
, ys: list (b, n)
, f: (a, b) -<cloref1> c
) : list (c, n) = case+ (xs, ys) of
  | (list_cons (x, xs), list_cons (y, ys)) =>
      list_cons (f (x, y), list_zipwith (xs, ys, f))
  | (list_nil (), list_nil ()) => list_nil ()
// end of [list_zipwith]
")

Each element z in zs equals f(x, y), where x and y are the corresponding
elements in xs and ys, respectively.  Clearly, this implementation of
#code("list_zipwith") is not tail-recursive.
")#comment("para")

</sect2><!--id="list_zipping_with"-->

</sect1><!--id="example_function_templates_on_lists_redux"-->

<!-- ****** ****** -->

<sect1 id="example_mergesort_redux">
<title>
Example: Mergesort on Lists (Redux)
</title>

#para('\

I have previously presented an <xref linkend="example_mergesort"/>
that are formed with the constructors #code("list0_nil") and
#code("list0_cons").  In this section, I give an implementation of
mergesort on lists formed with the constructors #code("list_nil") and
#code("list_cons"). This implementation is based on the same algorithm
as the previous one but it assigns a type to the implemented sorting
function that guarantees the function to be length-preserving, that is, the
function always returns a list of the same length as the list it sorts.

')#comment("para")

#para("\
The following defined function #code("merge") combines two
ordered list (according to a given ordering) into a single ordered list:

#atscode("\
typedef lte (a:t@ype) = (a, a) -> bool

fun{a:t@ype}
merge {m,n:nat} .<m+n>. (
  xs: list (a, m), ys: list (a, n), lte: lte a
) : list (a, m+n) =
  case+ xs of
  | list_cons (x, xs1) => (
    case+ ys of
    | list_cons (y, ys1) =>
        if x \lte y then
          list_cons (x, merge (xs1, ys, lte))
        else
          list_cons (y, merge (xs, ys1, lte))
        // end of [if]
    | list_nil () => xs
    ) // end of [list_cons]
  | list_nil () => ys
// end of [merge]
")

Clearly, the type assigned to #code("merge") indicates that the
function returns a list whose length equals the sum of the lengths of the
two input lists. Note that a termination metric is present for verifying
that #code("merge") is a terminating function.
")#comment("para")

#para("\
The following defined function #code("mergesort") mergesorts a
list according to a given ordering:

#atscode("\
fun{a:t@ype}
mergesort {n:nat} (
  xs: list (a, n), lte: lte a
) : list (a, n) = let
  fun msort {n:nat} .<n,n>. (
    xs: list (a, n), n: int n, lte: lte a
  ) : list (a, n) =
    if n >= 2 then split (xs, n, lte, n/2, list_nil) else xs
  // end of [msort]
  and split
    {n:int | n >= 2} {i:nat | i <= n/2} .<n,i>. (
    xs: list (a, n-n/2+i)
  , n: int n, lte: lte a, i: int i, xsf: list (a, n/2-i)
  ) : list (a, n) =
    if i > 0 then let
      val+ list_cons (x, xs) = xs
    in
      split (xs, n, lte, i-1, list_cons (x, xsf))
    end else let
      val xsf = list_reverse<a> (xsf) // make sorting stable!
      val xsf = list_of_list_vt (xsf) // linear list -> nonlinear list
      val xsf = msort (xsf, n/2, lte) and xs = msort (xs, n-n/2, lte)
    in
      merge (xsf, xs, lte)
    end // end of [if]
  // end of [split]
  val n = list_length<a> (xs)
in
  msort (xs, n, lte)
end // end of [mergesort]
")

The type assigned to #code("mergesort") indicates that
#code("mergesort") returns a list of the same length as its input list.
The two inner functions #code("msort") and #code("split") are
defined mutually recursively, and the termination metrics for them are
pairs of natural numbers that are compared according to the standard
lexicographic ordering on integer sequences. The type assigned to
#code("msort") clearly indicates that its integer argument is required
to be the length of its list argument, and a mismatch between the two
surely results in a type-error.  The type assigned to #code("split") is
particularly informative, depicting a relation between the arguments and
the return value of the function that can be of great help for someone
trying to understand the code.  The function #code("list_reverse")
returns a linear list that is the reverse of its input, and the cast
function #code("list_of_list_vt") turns a linear list into a nonlinear
one (while incuring no cost at run-time). I will explain what linear lists
are elsewhere.
")#comment("para")

#para("\
Please find the entire code in this section plus some additional
code for testing #mycodelink("CHAPTER_DEPREFDTS/mergesort.dats", "on-line").
")

</sect1><!--id="example_mergesort_redux"-->

<!-- ****** ****** -->

<sect1
id="sequentiality_of_pattern_matching"
>#title("Sequentiality of Pattern Matching")

#para("\

In ATS, pattern matching is performed sequentially at run-time. In other
words, a clause is selected only if a given value matches the pattern
guard associated with this clause but the value fails to match the pattern
associated with any clause ahead of it. Naturally, one may expect that the
following implementation of #code("list_zipwith") also typechecks:

#atscode("\
fun{a1,a2:t@ype}{b:t@ype}
list_zipwith {n:nat} (
  xs1: list (a1, n)
, xs2: list (a2, n)
, f: (a1, a2) -<cloref1> b
) : list (b, n) =
  case+ (xs1, xs2) of
  | (list_cons (x1, xs1), list_cons (x2, xs2)) =>
      list_cons (f (x1, x2), list_zipwith (xs1, xs2, f))
  | (_, _) => list_nil ()
// end of [list_zipwith]
")

This, however, is not the case. In ATS, typechecking clauses is done
nondeterministically (rather than sequentially). In this example, the
second clause fails to typecheck as it is done without the assumption that
the given value pair #code("(xs1, xs2)") fails to match the pattern
guard associated with the first clause.  The second clause can be modified
slightly as follows to pass typechecking:

#atscode("\
  | (_, _) =>> list_nil ()
")

The use of the symbol #code("=>>") (in place of #code("=>")) indicates to
the typechecker that this clause needs to be typechecked under the
sequentiality assumption that the given value that matches it does not
match the pattern guards associated with any previous clauses. Therefore,
when the modified second clause is typechecked, it can be assumed that the
value pair #code("(xs1, xs2)") matching the pattern #code("(_, _)") must
match one of the following three patterns:

<itemizedlist>

<listitem>
#para("
#code("(list_cons (_, _), list_nil ())")
")
</listitem>

<listitem>
#para("
#code("(list_nil (), list_cons (_, _))")
")
</listitem>

<listitem>
#para("
#code("(list_nil (), list_nil ())")
")
</listitem>

</itemizedlist>

Given that #code("xs1") and #code("xs2") are of the same length,
the typechecker can readily infer that #code("(xs1, xs2)") cannot match
either of the first two patterns. After these two patterns are ruled out,
typechecking is essentially done as if the second clause was written as follows:

#atscode("\
  | (list_nil (), list_nil ()) => list_nil ()
")

")#comment("para")

#para("\
One may be wondering why typechecking clauses is not required to be
done sequentially by default. The simple reason is that this requirement,
if fully enforced, can have a great negative impact on the efficiency of
typechecking. Therefore, it is a reasonable design to provide the
programmer with an explict means to occasionally make use of the
sequentiality assumption needed for typechecking a particular clause.
")

</sect1><!--id="sequentiality_of_pattern_matching"-->

<!-- ****** ****** -->

<sect1
id="example_fun_random-access_lists"
>#title("Example: Functional Random-Access Lists")

#para("\
The data structure I implement in this section is based on one
presented in the book titled <emphasis> Pure Funtional Data Structures
</emphasis> by Chris Okasaki, where more elaboration on data structures of
this kind can be found.
")

#para("\
Let us first declare a datatype as follows:

#atscode("\
typedef pt (a:t@ype) = '(a, a)

datatype
ralist (a:t@ype+, n:int) =
  | RAnil (a, 0)
  | {n:pos} RAevn (a, 2*n) of ralist (pt a, n)
  | {n:nat} RAodd (a, 2*n+1) of (a, ralist (pt a, n))
// end of [ralist]
")

Given an unboxed type T and a static integer, the type
#code("ralist")(T, I) is a boxed type for values representing
lists of length I. The meaning of the three constructors
#code("RAnil"), #code("RAevn") and #code("RAodd") can be
briefly explained as follows:

<itemizedlist>

<listitem>
#para("
The constructor #code("RAnil") is for constructing a value representing
the empty list.
")
</listitem>

<listitem>
#para("\
In order to construct a value representing a list of 2*I
elements for some I > 0, we first construct a value representing a list of
I pairs of adjacent elements in the (original) list and then apply the
constructor #code("RAevn") to the value.
")
</listitem>

<listitem>
#para("\
In order to construct a value representing a list of
2*I+1 elements for some I >= 0, we take out the head of the list and
construct a value representing a list of I pairs of adjacent elements in
the tail of the (original) list and then apply the constructor
#code("RAodd") to the head element and the value.
")
</listitem>

</itemizedlist>

For example, the list of the first 5 positive integers is represented by the
following value:

#atscode("\
RAodd(1, RAevn(RAodd( '( '(2, 3), '(4, 5) ), RAnil())))
")

Values constructed by the constructors #code("RAnil"),
#code("RAevn") and #code("RAodd") represent lists that support
operations of logrithmic time for accessing and updating list elements, and
such lists are often referred to as random-access lists.
")#comment("para")

#para("\
Note that the datatype #code("ralist") is not supported in ML
even if the index representing list length is erased. This kind of
datatypes are often referred to as nested datatypes, which are also
supported in Haskell.
")

#para("\
The following defined function #code("ralist_length") computes
the length of a random-access list:

#atscode("\
fun{a:t@ype}
ralist_length // O(log n)
  {n:nat} .<n>.
  (xs: ralist (a, n)): int n =
  case+ xs of
  | RAnil () => 0
  | RAevn xxs => 2 * ralist_length<pt(a)> (xxs)
  | RAodd (_, xxs) => 2 * ralist_length<pt(a)> (xxs) + 1
// end of [ralist_length]
")

While the implementation of #code("ralist_length") is clearly not
tail-recursive, this is hardly of any practical concern as the
time-complexity of #code("ralist_length") is O(log(n)).
")#comment("para")

#para("\
Consing means to form a new list with an element and a list such
that the element and the list are the head and tail of the new list. The
following defined function #code("ralist_cons") implements consing
for random-access lists:

#atscode("\
fun{a:t@ype}
ralist_cons // O(1), amortized
  {n:nat} .<n>.
  (x0: a, xs: ralist (a, n)): ralist (a, n+1) =
  case+ xs of
  | RAnil () => RAodd (x0, RAnil)
  | RAevn (xxs) => RAodd (x0, xxs)
  | RAodd (x1, xxs) =>
      RAevn (ralist_cons<pt(a)> ( '(x0, x1), xxs ))
    // end of [RAodd]
// end of [ralist_cons]
")

In the worst case (where the length of #code("xs") is a power of 2
minus 1), #code("ralist_cons") takes O(log(n))-time to finish. However,
it can be proven that the amortized time-complexity of consing on
random-access lists is O(1).
")#comment("para")

#para("\
Unconsing does the opposite of consing: It returns a pair consisting
of the head and tail of a given non-empty list.  The following defined
function #code("ralist_uncons") implements unconsing for random-access
lists:

#atscode("\
fun{a:t@ype}
ralist_uncons // O(1), amortized
  {n:pos} .<n>.
  (xs: ralist (a, n)): (a, ralist (a, n-1)) =
  case+ xs of
  | RAevn (xxs) => let
      val (xx, xxs) = ralist_uncons<pt(a)> (xxs)
    in
      (xx.0, RAodd (xx.1, xxs))
    end // end of [RAevn]
  | RAodd (x, xxs) => (case+ xxs of
(*
// Note: [=>>] is needed for enforcing sequentiality
// during typechecking:
*)
      RAnil () => (x, RAnil) | _ =>> (x, RAevn (xxs))
    ) // end of [RAodd]
// end of [ralist_uncons]
")

Like #code("ralist_cons"), #code("ralist_uncons") takes
O(log(n))-time to finish when the length of #code("xs") is a power of
2. However, its amortized time-complexity is also O(1).  It is highly
probable for a programmer to implement the second matching clause in the
body of #code("ralist_uncons") as follows:

#atscode("\
  | RAodd (x, xxs) => (x, RAevn (xxs))
")

For instance, I myself did this.  This is a program error as the invariant
can potentially be broken that states #code("RAevn") being only applied
to a value representing a non-empty list. The error is readily caught by
the typechecker of ATS but it is most likely to go unnoticed in a setting
where the invariant on the constructor #code("RAevn") can not be
captured at compile-time.
")#comment("para")

#para("\
Given a random-access list xs of length n, the elements in it are
numbered from 0 to n-1, inclusively. We can find element i in the list xs,
where i is assumed to be a natural number less than n, by implementing the
following algorithm:

<itemizedlist>

<listitem>
#para("\
Assume the length n is even. Then xs is of the form
#code("RAevn")(xxs), where xxs is a list of pairs. Let i2 be i/2 and we
find element i2 in xxs, which is a pair. Let xx refer to this pair. If i is
even, then the left component of xx is element i in xs. Otherwise, the
right component is.
")#comment("para")
</listitem>

<listitem>
#para("\
Assume the length n is odd. Then xs is of the form
#code("RAodd")(x, xxs), where xxs is a list of pairs. If i equals 0,
the x is element i in xs. Otherwise, let i1 be i-1 and i2 be i1/2 and we
find element i2 in xxs, which is a pair. Let xx refer to this pair. If i1 is
even, then the left component of xx is element i in xs. Otherwise, the
right component is.
")#comment("para")
</listitem>

</itemizedlist>

The following function #code("ralist_lookup") is implemented precisely
according to the given algorithm:

#atscode("\
fun{a:t@ype}
ralist_lookup // O(log(n))-time
  {n:int} {i:nat | i < n} .<n>.
  (xs: ralist (a, n), i: int i): a =
  case+ xs of
  | RAevn xxs => let
      val i2 = i / 2
      val lr = i - 2 * i2
      val xx = ralist_lookup<pt(a)> (xxs, i2)
    in
      if lr = 0 then xx.0 else xx.1
    end // end of [RAevn]
  | RAodd (x, xxs) =>
      if i > 0 then let
        val i1 = i - 1
        val i2 = i1 / 2
        val lr = i1 - 2 * i2
        val xx = ralist_lookup<pt(a)> (xxs, i2)
      in
        if lr = 0 then xx.0 else xx.1
      end else x
    // end of [RAodd]
// end of [ralist_lookup]
")

Clearly, the time complexity of #code("ralist_lookup") is O(log(n)).
")#comment("para")

#para("\
Given a random-access list xs of length n, an index that is a
natural number less than n and an element x0, the following defined
function #code("ralist_update") returns another random-access that is
the same as xs except element i in it being x0:

#atscode("\
fun{a:t@ype}
ralist_update // O(log(n))-time
  {n:int} {i:nat | i < n} .<n>. (
    xs: ralist (a, n), i: int i, x0: a
  ) : ralist (a, n) = let
//
  fun{a:t@ype} fupdate
    {n:int} {i:nat | i < n} .<n,1>. (
      xs: ralist (a, n), i: int i, f: a -<cloref1> a
    ) : ralist (a, n) =
    case+ xs of
    | RAevn xxs =>
        RAevn (fupdate2 (xxs, i, f))
    | RAodd (x, xxs) =>
        if i > 0 then
          RAodd (x, fupdate2 (xxs, i-1, f))
        else RAodd (f(x), xxs)
   (* end of [fupdate] *)
//
   and fupdate2
     {n2:int} {i:nat | i < n2+n2} .<2*n2,0>. (
       xxs: ralist (pt(a), n2), i: int i, f: a -<cloref1> a
     ) : ralist (pt(a), n2) = let
     val i2 = i / 2
     val lr = i - 2 * i2
     val f2 = (
       if lr = 0 then
         lam xx => '(f(xx.0), xx.1)
       else
         lam xx => '(xx.0, f(xx.1))
     ) : pt(a) -<cloref1> pt(a)
   in
     fupdate<pt(a)> (xxs, i2, f2)
   end // end of [fupdate2]
//
in
  fupdate (xs, i, lam _ => x0)
end // end of [ralist_update]
")#comment("atscode")

Note that the functions #code("fupdate") and #code("fupdate2") are
higher-order. Given a random-access list xs of length n, an index i that is
a natural number less than n and a (closure) function f,
#code("fupdate") returns another random-access list that is the same as
xs except element i in it being f(x), where x is element i in xs. It is
straightforward to see that the time-complexity of
#code("ralist_update") is O(log(n)).  I leave the reader to figure out
further details on this interesting implementation.
")#comment("para")

#para("\
The code employed for illustration in this section plus some additional
code for testing is available #mycodelink("CHAPTER_DEPREFDTS/ralist.dats", "on-line").
")

</sect1><!--id="example_fun_random-access_lists"-->

<!--****** ******-->

<sect1
id="example_fun_red-black_trees"
xreflabel="implementation of functional red-black trees"
>#title("Example: Functional Red-Black Trees")

#para('\

A red-black tree is defined as a binary tree such that each node in it is
colored red or black and every path from the root to a leaf has the same
number of black nodes while containing no occurrences of two red nodes in a
row.  Clearly, the length of a longest path in each red-black tree is
bounded by 2 times the length of a shortest path in it. Therefore,
red-black trees are a family of balanced trees. The number of black nodes
occurring on each path in a red-black tree is often referred to as the
#emph("black height") of the tree.

')

#para('\

Formally, a datatype precisely for red-black trees can be declared in ATS
as follows:

')

#atscode('\
\#define BLK 0
\#define RED 1
sortdef clr = {c:nat | c <= 1}

datatype rbtree
  (a:t@ype+, int(*clr*), int(*bh*)) =
  | {c,cl,cr:clr | cl <= 1-c; cr <= 1-c} {bh:nat}
    rbtree_cons (a, c, bh+1-c) of (int c, rbtree (a, cl, bh), a, rbtree (a, cr, bh))
  | rbtree_nil (a, BLK, 0)
// end of [rbtree]
')

#para('\

The color of a tree is the color of its root node or is black if the tree
is empty.  Given a type T, a color C (represented by a integer) and an
integer BH, the type #code("rbtree")(T, C, BH) is for red-black trees
carrying elements of the type T that is of the color C and the black height
BH.

')

#para('\

When implementing various operations (such as insertion and deletion) on a
red-black tree, we often need to first construct intermediate trees that
contain color violations caused by a red node being followed by another red
node and then employ tree rotations to fix such violations. This need makes
the above datatype #code("rbtree") too rigid as it cannot be assigned to
any intermediate trees containing color violations. To address this issue,
we can declare #code("rbtree") as follows:

')

#atscode('\
datatype
rbtree (
  a:t@ype+, int(*clr*), int(*bh*), int(*v*)
) = // element type, color, black height, violations
  | rbtree_nil (a, BLK, 0, 0) of ()
  | {c,cl,cr:clr} {bh:nat} {v:int}
      {c==BLK && v==0 || c == RED && v==cl+cr}
    rbtree_cons (a, c, bh+1-c, v) of (
      int c, rbtree0 (a, cl, bh), a, rbtree0 (a, cr, bh)
    ) // end of [rbtree_cons]
// end of [rbtree]

where rbtree0 (a:t@ype, c:int, bh:int) = rbtree (a, c, bh, 0)
')

#para('\

We count each occurrence of two red nodes in a row as one color violation.
Given a type T, a color C (represented by a integer), an integer BH and an
integer V, the type #code("rbtree")(T, C, BH, V) is for trees carrying
elements of the type T that is of the color C and the black height BH and
contains exactly V color violations. Therefore, the type #code("rbtree")(T,
C, BH, 0) is for valid red-black trees (containing no color violations).

')

#para('\

Given a tree containing at most one color violation, an element and another
tree containing no violations, the following operation constructs a valid
red-black tree:

')

#atscode('\
fn{a:t@ype}
insfix_l // right rotation for fixing left insertion
  {cl,cr:clr} {bh:nat} {v:nat} (
  tl: rbtree (a, cl, bh, v), x0: a, tr: rbtree (a, cr, bh, 0)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK; \#define R RED; \#define cons rbtree_cons
in
  case+ (tl, x0, tr) of
  | (cons (R, cons (R, a, x, b), y, c), z, d) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // shallow rot
  | (cons (R, a, x, cons (R, b, y, c)), z, d) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // deep rotation
  | (a, x, b) =>> cons (B, a, x, b)
end // end of [insfix_l]
')

#para('\

By simply reading the interface of #code("insfix_l"), we can see that the
two tree arguments are required to be of the same black height bh for some
natural number bh and the returned tree is of the black height bh+1.

')

#para('\

The following operation #code("insfix_r") is just the mirror image of
#code("insfix_l"):

')

#atscode('\
fn{a:t@ype}
insfix_r // left rotation for fixing right insertion
  {cl,cr:clr} {bh:nat} {v:nat} (
  tl: rbtree (a, cl, bh, 0), x0: a, tr: rbtree (a, cr, bh, v)
) : [c:clr] rbtree0 (a, c, bh+1) = let
  \#define B BLK; \#define R RED; \#define cons rbtree_cons
in
  case+ (tl, x0, tr) of
  | (a, x, cons (R, b, y, cons (R, c, z, d))) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // shallow rot
  | (a, x, cons (R, cons (R, b, y, c), z, d)) =>
      cons (R, cons (B, a, x, b), y, cons (B, c, z, d)) // deep rotation
  | (a, x, b) =>> cons (B, a, x, b)
end // end of [insfix_r]
')

#para('\

The preparation for implementing insertion on a red-black tree is all done
by now, and we are ready to see an implementation of insertion guaranteeing
that the tree obtained from inserting an element into a given red-black
tree is always a valid red-black tree itself. This guarantee is precisely
captured in the following interface for insertion:

')

#atscode('\
extern
fun{a:t@ype}
rbtree_insert
  {c:clr} {bh:nat} (
  t: rbtree0 (a, c, bh), x0: a, cmp: cmp a
) : [bh1:nat] rbtree0 (a, BLK, bh1)
')

#para('\

Interestingly, this interface also implies that the tree returned by a call
to #code("rbtree_insert") is always black. The code presented below gives
an implementation of #code("rbtree_insert"):

')

#atscode('\
implement{a}
rbtree_insert
  (t, x0, cmp) = let
  \#define B BLK; \#define R RED
  \#define nil rbtree_nil; \#define cons rbtree_cons
  fun ins
    {c:clr} {bh:nat} .<bh,c>. (
    t: rbtree0 (a, c, bh), x0: a
  ) :<cloref1> [cl:clr; v:nat | v <= c] rbtree (a, cl, bh, v) =
    case+ t of
    | cons (c, tl, x, tr) => let
        val sgn = compare (x0, x, cmp)
      in
        if sgn < 0 then let
          val [cl,v:int] tl = ins (tl, x0)
        in
          if c = B then insfix_l (tl, x, tr)
            else cons {..}{..}{..}{cl} (R, tl, x, tr)
          // end of [if]
        end else if sgn > 0 then let
          val [cr,v:int] tr = ins (tr, x0)
        in
          if c = B then insfix_r (tl, x, tr)
            else cons {..}{..}{..}{cr} (R, tl, x, tr)
          // end of [if]
        end else t // end of [if]
      end // end of [cons]
    | nil () => cons {..}{..}{..}{0} (R, nil, x0, nil)
  // end of [ins]
  val t = ins (t, x0)
in
  case+ t of cons (R, tl, x, tr) => cons (B, tl, x, tr) | _ =>> t
end // end of [rbtree_insert]
')

#para('\

Note that the type assigned to the inner function #code("ins") is so
informative that it literally gives an formal explanation about the way in
which insertion works on a red-black tree. Many a programmer implements
red-black trees by simply following an algorithm written in some format of
pseudo code while having little understanding about the innerworkings of
the algorithm. For instance, if the above inner function #code("ins") is
implemented in C, few programmers are likely to see that the function
always maintain the black height of a given red-black tree after insertion
but may introduce one color violation if the root of the tree is red. On
the other hand, knowing this invariant is essential to gaining a thorough
understanding of the insertion algorithm on red-black trees.

')

#para('\

The insertion operation implemented above does not insert an element if it
is already in the given red-black tree. It may be desirable to require that
the operation inform the caller if such a case occurs. For instance, an
exception can be raised for this purpose. An alternative is to give
#code("rbtree_insert") a call-by-reference argument so that a flag can be
returned in it to indicate whether the element to be inserted is actually
inserted. I will explain elsewhere what call-by-reference is and how it is
supported in ATS.

')

#para('\

Often deleting an element from a binary search tree is significantly more
difficult to implement than inserting one.  This is especially so in the
case of a red-black tree.  I refer the interested reader to the libats
library of ATS for some code implementing a deletion operation on red-black
trees that can guarantee based on types each tree returned by the operation
being a valid red-black tree (containing no color violations).

')

#para("\

Please find the entire code in this section plus some additional code for
testing #mycodelink("CHAPTER_DEPREFDTS/rbtree.dats", "on-line").

")

</sect1><!--id="example_fun_red-black_trees"-->

</chapter><!--id="datatype_refinement"-->

#comment(" ****** ****** ")
#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
