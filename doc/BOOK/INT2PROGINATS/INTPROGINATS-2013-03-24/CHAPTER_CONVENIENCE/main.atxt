%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include "./../proginatsatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="convenience_in_programming">
#title("Convenience in Programming")

#para('\

There are a variety of programming features in ATS that are
primarily designed to provide convienience in programming.  In this
chapter, I will cover macros, compile-time directives and several forms of
overloading.\

')

<sect1 id="macro_definitions">
#title("Macro Definitions")

#para('\

There are two kinds of macros in ATS: a C-like kind and a LISP-like kind
respectively.\

')

<sect2 id="c-like_macros">
#title("C-like Macros")

#para('\

The following two declarations bind the identifiers #code("N1") and
#code("N2") to the abstract syntax trees (not strings) representing
#code("1024") and #code("N1 + N1"), respectively:

')

#atscode('\
\#define N1 1024
\#define N2 N1 + N1
')

#para('\

Suppose we have the following value declaration appearing in the scope of
the above macro delarations:

')

#atscode('\
val x = N1 * N2
')

#para('\

Then #code("N1 * N2") first expands into #code("1024 * (N1 + N1)"),
which further expands into #code("1024 * (1024 + 1024)"). Note that if
this example is done in C, then #code("N1 * N2") expands into
#code("1024 * 1024 + 1024"), which is different from what we have here.
Also note that it makes no difference if we reverse the order of the
previous macro definitions:

')

#atscode('\
\#define N2 N1 + N1
\#define N1 1024
')

#para('\

If we now introduce the following declaration:

')

#atscode('\
\#define N3 %(N1 + N1) + N2
')


#para('\

then the name #code("N3") is bound to the abstract syntax tree of
#code("2048 + N2"). In general, an expression of the form
#code("%(exp)") refers to the abstract syntax tree representing the
value of exp.\

')

#para('\

If we declare a marco as follows:

')

#atscode('\
\#define LOOP (LOOP + 1)
')

#para('\

then an infinite loop is entered (or more precisely, some macro expansion
depth is to be reached) when the identifier #code("LOOP") is expanded.
There is currently no guard against infinite macro expansion in ATS, and
the propgrammer is fully responsible for avoiding it.

')

</sect2><!--id="c-like_macros"-->

<sect2 id="lisp-like_macros">
#title("LISP-like Macros")

#para('\

There are two forms of LISP-like macros in ATS: short form and long form.
These (untyped) macros are highly flexible and expressive, and they
can certainly be used in convoluted manners that should probably be
avoided in the first place. Some commonly used macro definitions can be
found <ulink
url="http://www.ats-lang.org/DOCUMENTATION/ANAIRIATS/prelude/macrodef.sats">on-line</ulink>.
In order to use LISP-like macros in ATS effectively, the programmer may
want to study some examples in LISP involving backquote-comma-notation.

')

<sect3>
<title>Macros in Long Form</title>

#para('\

As a macro in short form can simply
be considered a special kind of macro in long form, we first give some
explanantion on the latter.  A macro definition in long form is introduced
through the use of the keyword #code("macrodef"). For instance, the following
syntax introduces a macro name #code("one") that refers to some code, that
is, abstract syntax tree (AST) representing the integer number #code("1").

')

#atscode('\
macrodef one = `(1)
')

#para('\

The special syntax `(exp), where no space is allowed between the backquote
(#code("`")) and the left parenthsis (#code("(")), means to form an
abstract syntax tree representing the expression written inside the
parentheses.  This is often referred to as backquote-notation. Intuitively,
one may think that a backquote-notation exerts an effect that
<emphasis>freezes</emphasis> everything inside it.  Let us now define
another macro as follows:
')

#atscode('\
macrodef one_plus_one = `(1 + 1)
')

#para('\

The defined macro name #code("one_plus_one") refers to some code (i.e., AST)
representing #code("1 + 1"). At this point, it is important to stress that
the code representing #code("1 + 1") is different from the code representing
#code("2").  The macro name #code("one_plus_one") can also be defined as
follows:

')

#atscode('\
macrodef one_plus_one = `(,(one) + ,(one))
')

#para('\

The syntax ,(exp), where no space is allowed between the comma
(#code(",")) and the left parenthesis (#code("(")), indicates the
need to expand (or evaluate) the expression written inside the
parentheses. This is often referred to as comma-notation, which is only
allowed inside a backquote-notation. Intuitively, a comma-notation cancels
out the <emphasis>freezing</emphasis> effect of the enclosing
backquote-notation.

')

#para('\

In addition to macro names, we can also define macro functions. For
instance, the following syntax introduces a macro function
#code("cube_mac"):

')

#atscode('\
macrodef cube_mac (x) =
  `(,(x) * ,(x) * ,(x)) // [x] should refer to some code
')

#para('\
Here are some examples that make use of #code("cube_mac"):
')

#atscode('\
fun cubesum (i:int, j: int): int =
  ,(cube_mac `(i)) +  ,(cube_mac `(j))
fun volOfSphere (r: double): double =
  4.0 * 3.1416 * ,(cube_mac `(r)) / 3
')

#para('\
After macro expansion, the definitions of the functions
#code("cubesum") and #code("volOfSphere") can be written as
')

#atscode('\
fun cubesum (i: int, j: int): int = (i * i * i) + (j * j * j)
fun volOfSphere (r: double): double = 4.0 * 3.1416 * (r * r * r) / 3
')

</sect3>

<sect3>
#title("Macros in Short Form")

#para('\
The previous macro function #code("cube_mac") can also be defined as
follows:
')

#atscode('\
macdef cube_mac (x) = ,(x) * ,(x) * ,(x) // [x] should refer to some code
')

#para('\
The keyword #code("macdef") introduces a macro definition in short form.
The previous examples that make use of #code("cube_mac") can now be written
as follows:
')

#atscode('\
fun cubesum (i:int, j: int): int = cube_mac (i) +  cube_mac (j)
fun volOfSphere (r: double): double = 4.0 * 3.1416 * cube_mac (r) / 3
')

#para('\

In terms of syntax, a macro function in short form is just like an ordinary
function.  In general, if a unary macro function #code("fmac") in short
form is defined as as follows:

')

#atscode('\
macdef fmac (x) = exp
')

#para('\

where exp stands for some expression, then one may essentially think that a
macro definition in long form is defined as follows:

')

#atscode('\
macrodef lfmac (x) = `(exp) // please note the backquote
')

#para('\

and each occurrence of #code("fmac(arg)") for some expresson arg is
automatically rewritten into #code(",(lfmac(`(arg)))"). Note that
macro functions in short form with multiple arguments are handled
analogously.\

')

#para('\

The primary purpose for introducing macros in short form is to
provide a form of syntax that seems more accessible. While macros in long
form can be defined recursively (as is to be explained later), macros in
short form cannot.

')

</sect3>

</sect2><!--id="lisp-like_macros"-->

</sect1><!--id="macro_definitions"-->

<!-- ****** ****** -->

<sect1 id="compile-time_directives">
#title("Compile-Time Directives")

#para("")

</sect1><!--id="compile-time_directives"-->

<!-- ****** ****** -->

<sect1 id="overloading">
#title("Overloading")

#para('\

I will cover in this section several forms of overloading supported
in ATS: static constant overloading, data constructor overloading and
dynamic function overloading.\

')

<!-- ****** ****** -->

<sect2 id="static_constant_overloading">
#title("Static Constant Overloading")

#para("")

</sect2><!--id="static_constant_overloading"-->

<!-- ****** ****** -->

<sect2 id="data_constructor_overloading">
#title("Data Constructor Overloading")

#para("")

</sect2><!--id="data_constructor_overloading"-->

<!-- ****** ****** -->

<sect2 id="function_overloading">
#title("Dynamic Function Overloading")

#para('\

A symbol in ATS can be overloaded with multiple (dynamic)
functions. The following syntax introduces a symbol of the name
#code("foo") for overloading:\

')

#atscode('\
symintr foo // symbol introduction for overloading
')

#para('\

Suppose that #code("foo1"), #code("foo2") and #code("foo3") are
names of three functions in ATS. Then we can overload #code("foo") with
these three functions as follows:\

')

#atscode('\
overload foo with foo1
overload foo with foo2
overload foo with foo3
')

#para('\

An overloaded function symbol is resolved according to the number of
arguments it takes and, if needed, the types of these arguments.

')

</sect2><!--id="function_overloading"-->

</sect1><!--id="overloading"-->

<!-- ****** ****** -->

</chapter><!--id="convenience_in_programming"-->

#comment(" ****** ****** ")
#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
