%{
//
dynload
"libatsdoc/dynloadall.dats"
//
#include "./../proginatsatxt.dats"
//
%}\
#comment("\n\
The file is automatically generated by [atsdoc] from main.atxt.\n\
")
#comment("\n\
Time of Generation: #timestamp()\
")
<chapter id="modularity">
<title>Modularity</title>

#para("\
Generally speaking, modularity in programming means to organize
programs in a modular fashion so that they each can be constructed in a
relatively isolated manner and then be combined to function coherently.  I
will introduce in this section some features in ATS that are largely
designed to facilitate program organization.
")

#para("\
The code employed for illustration in this chapter plus some
additional code for testing is available #mycodelink("CHAPTER_MODULARITY/", "on-line").
")

<!-- ****** ****** -->

<sect1 id="types_as_a_form_of_specification">
<title>
Types as a Form of Specification
</title>

#para("\
The interface for a function or value specifies a type that any
implementation of the function or value should possess. For instance, the
following code defines a function #code("fact") for computing the
factorial numbers:

#atscode('\
fun fact (x: int): int = if x > 0 then x * fact (x-1) else 1
')

It is also possible to first declare an interface for #code("fact") as
follows:

#atscode('\
extern fun fact (x: int): int
')

where #code("extern") is a keyword in ATS that initiates the
declaration of an interface. I will mention later an occasion where the
keyword #code("extern") should be dropped.  An alternative way to
declare an interface for #code("fact") is given as follows:

#atscode('\
extern val fact : (int) -> int
')

If #code("fact") is declared to be a function, then it is required to
be applied when occurring in code. If it is declared to be a value, there
is no such a restriction.
")#comment("para")

#para("\
A function interface can be considered as a form of
specification. For instance, the above interface for #code("fact")
specifies that #code("fact") is a function that takes one integer
argument and returns an integer value. What is so special about this form
of specification is that it is formally enforced in ATS through
typechecking: Any implementation of #code("fact") in ATS must possess
the interface declared for it.  Of course, this is not a precise
specification for #code("fact") as there are (infinite) many functions
that can be given the same interface. This kind of imprecision can,
however, be reduced or even eliminated, sometimes. After dependent types
are introduced, I will present an interface for #code("fact") such that
any implementation of the interface is guaranteed to implement precisely
the factorial function as is defined by the following two equations:

<itemizedlist>

<listitem>
#para("
fact(0) = 1
")
</listitem>

<listitem>
#para("
fact(n) = n * fact (n-1) for each natural number n > 0
")
</listitem>

</itemizedlist>

")#comment("para")

#para("\
An implementation for #code("fact") as the following one can be
given at any point where the declared interface for #code("fact") is
accessible:

#atscode('\
implement fact (x) = if x > 0 then x * fact (x-1) else 1
')

The keyword #code("implement") is for initiating an implementation of a
function or value whose interface is already declared.

")#comment("para")

#para("\
As an example of an interface for a value, #code("fact10") is
declared as follows to be a value of the type #code("int"):

#atscode('\
extern val fact10 : int
')

The following implementation for #code("fact10") can be given at any
point where the declared interface for #code("fact10") is accessible:

#atscode('\
implement fact10 = fact (10)
')

")#comment("para")

#para("\
As another example, the following code declares an interface for a
polymorphic function named #code("swap_boxed"):

#atscode('\
extern fun swap_boxed {a,b:type} (xy: (a, b)): (b, a)
')

Note that both type variables #code("a") and #code("b") are boxed.
An implementation for #code("swap_boxed") is given as follows:

#atscode('\
implement swap_boxed {a,b} (xy) = (xy.1, xy.0)
')

The syntax #code("{a,b}") is for passing static arguments
#code("a") and #code("b") to #code("swap_boxed")
simultaneously. As neither #code("a") nor #code("b") is actually
used in the body of #code("swap_boxed"), it is allowed to drop
#code("{a,b}") in this case.
")#comment("para")

#para("\
It is a standard practice for a programmer to first design
interfaces for the functions to be supported in a package before actually
implementing any of these functions. When such interfaces are available,
application programs can be constructed to check whether the interface
design makes sense or is convenient for practical use. Please remember that
a superb implementation of a poor design cannot make the design any
better. Therefore, testing a design before actually implementing it is
often of vital importance. This is especially true if the involved design
is complex.
")

</sect1><!--id="types_as_a_form_of_specification"-->

<sect1 id="static_and_dynamic_ats_files">
<title>
Static and Dynamic ATS Files
</title>

#para("\
The first letters in the ATS filename extensions
<emphasis>sats</emphasis> and <emphasis>dats</emphasis> refer to the words
<emphasis>static</emphasis> and <emphasis>dynamic</emphasis>, respectively.
For instance, <filename>foo.sats</filename> is a name for a static file
while <filename>bar.dats</filename> for a dynamic one. A static file
usually contains interface declarations for functions and values, datatype
declarations, type definitions, etc. The primary purpose of such a file is
for allowing its content to be shared among various other ATS files, either
static or dynamic.
")

#para("\
Let us now go through a simple example to see a typical use of
static files. Suppose that we want to implement the Ackermann's function,
which is famous for being recursive but not primitive recursive.  In a
static file named <filename>acker.sats</filename> (or any other legal
filename), we can declare the following function interface:

#atscode('\
fun acker (m: int, n: int): int
')

Please note that we cannot use the keyword #code("extern") when
declaring an interface for either a function or a value in a static file.
Then in a dynamic file named <filename>acker.dats</filename> (or any other
legal filename), we can give the following implementation:

#atscode('\
staload "acker.sats"

implement
acker (m, n) =
  if m > 0 then
    if n > 0 then acker (m-1, acker (m, n-1))
    else acker (m-1, 1)
  else n+1
// end of [acker]
')

The keyword #code("staload") indicates to the ATS typechecker that the
file following it is to be statically loaded. Essentially, statically
loading a file means to put the content of the file in a namespace that can
be accessed by the code that follows. It is important to note that static
loading is different from plain file inclusion. The latter is also
supported in ATS, and it is a feature I will cover elsewhere.
")#comment("para")

#para("\
It is also possible to give the following implementation for the
declared function #code("acker"):

#atscode('\
staload ACKER = "acker.sats"

implement $ACKER.acker
  (m, n) = acker (m, n) where {
  fun acker (m: int, n:int): int = 
    if m > 0 then
      if n > 0 then acker (m-1, acker (m, n-1))
      else acker (m-1, 1)
    else n+1
} // end of [$ACKER.acker]
')

In this case, the namespace for storing the content of the file
<filename>acker.sats</filename> is given the name ACKER, and the prefix
#code("$ACKER.") (the dollar sign followed by ACKER followed by the dot
symbol) must be attached to any name that refers an entity (a function, a
value, a datatype, the constructors associated with a datatype, a type
definition, etc.) declared in <filename>acker.sats</filename>. When there
are many static files to be loaded, it is often a good practice to assign
names to the namespaces holding these files so that the original source of
each declared entity can be readily tracked down.
")#comment("para")

#para("\
In another file named <filename>test_acker.dats</filename>, let use
write the following code:

#atscode('\
staload "acker.sats"
dynload "acker.dats"

implement
main () = () where {
//
// acker (3, 3) should return 61
//
  val () = assertloc (acker (3, 3) = 61)
} // end of [main]
')

The keyword #code("dynload") indicates to the ATS compiler to generate
a call to the initializing function associated with the file
<filename>acker.dats</filename>. This is mandatory as an error would
otherwise be reported at link-time. Usually, calling the initializing
function associated with a dynamic file is necessary only if there is a
value implemented in the file. In this case, there is only a function
implemented
in <filename>acker.dats</filename>. If we include the following line somewhere
inside <filename>acker.dats</filename>:

#atscode('\
\#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
')

then the line starting with the keyword #code("dynload") in
<filename>test_acker.dats</filename> is no longer needed. The function
#code("assertloc") verifies at run-time that its argument evaluates to
the boolean value #code("true"). In the case where the argument
evaluates to #code("false"), the function call aborts and a message is
reported that contains the name of the file, which is
<filename>test_acker.dats</filename> in this example, and the location at
which the source code of the call is found in the file. If this sounds a
bit confusing, please try to execute a program that contains a call to
#code("assertloc") on #code("false") and you will see clearly what
happens.
")#comment("para")

#para("\
The simplest way to compile the three files #code("acker.sats"),
#code("acker.dats") and #code("test_acker.dats") is to issue the
following command-line:

<informalexample><programlisting>
<command>atscc</command> -o test_acker acker.sats acker.dats test_acker.dats
</programlisting></informalexample>

The generate excutable <filename>test_acker</filename> is in the current
working directory.  The compilation can also be performed separately as is
demonstrated below:

<informalexample><programlisting>
<command>atscc</command> -c acker.sats
<command>atscc</command> -c acker.dats
<command>atscc</command> -c test_acker.dats
<command>atscc</command> -o test_acker acker_sats.o acker_dats.o test_acker_dats.o
</programlisting></informalexample>

This style of separate compilation works particularly well when it is
employed by the <command>make</command> utility.
")#comment("para")

</sect1><!--id="static_and_dynamic_ats_files"-->

<!-- ****** ****** -->

<sect1 id="generic_template_implementation">
<title>
Generic Template Implementation
</title>

#para("\
Interfaces for function templates are mostly similar to those for
functions.  For example, the following syntax declares an interface in a
dynamic file for a function template of the name
#code("list0_fold_left"):

#atscode('\
extern fun{a:t@ype}{b:t@ype}
list0_fold_left (f: (a, b) -<cloref1> a, init: a, xs: list0 b): a
')

If the same interface is declared in a static file, the keyword
#code("extern") should be dropped. Implementing an interface for a
function template is also mostly similar to implementing one for a
function. The above interface for
#code("list0_fold_left") is given an implementation in the
following code:

#atscode('\
implement{a}{b}
list0_fold_left (f, init, xs) = let
  fun loop (init: a, xs: list0 b):<cloref1> a =
    case+ xs of
    | list0_cons (x, xs) => loop (f (init, x), xs)
    | list0_nil () => init
  // end of [loop]
in
  loop (init, xs)
end // end of [list0_fold_left]
')

Note that template parameters are required to appear immediately after the
keyword #code("implement"), and they cannot be omitted.  Template
parameters can also be passed sequentially as is shown in the following
short example:

#atscode("\
extern fun{a,b:t@ype}{c:t@ype}
app2 (f: (a, b) -<cloref1> c, x: a, y: b): c

implement{a,b}{c} app2 (f, x, y) = f (x, y)
")
")#comment("para")


#para("\
The style of template implementation presented in this section is
referred to as generic template implementation. I will later present a
different style of template implementation, which is often referred to as
specific template implementation.
")

</sect1><!--id="generic_template_implementation"-->

<!-- ****** ****** -->

<sect1 id="abstract_types">
<title>
Abstract Types
</title>

#para("\
The name <emphasis>abstract type</emphasis> refers to a type such
that values of the type are represented in a way that is completely hidden
from users of the type. This form of information-hiding attempts to ensure
that changes to the implementation of an abstract type cannot introduce
type-errors into well-typed code that makes use of the abstract type. In
ATS as well as in many other programming languages, abstract types play a
pivotal role in support of modular programming. I will present as follows a
concrete example to illustrate a typical use of abstract types in practice.
")

#para("\
Suppose that we are to implement a package to provide various
funtionalities on finite sets of integers. We first declare an abstract
type #code("intset") as follows for values representing finite sets of
integers:

#atscode("\
abstype intset // a boxed abstract type
")

The keyword #code("abstype") indicates that the declared abstract type
#code("intset") is boxed, that is, the size of #code("intset") is
the same as a pointer.  There is a related keyword #code("abst@ype")
for introducing unboxed abstract types, which will be explained elsewhere.
We next present an interface for each function or value that we want to
implement in the package:

#atscode("\
// empty set
val intset_empty : intset

// singleton set of [x]
fun intset_make_sing (x: int): intset

// turning a list into a set
fun intset_make_list (xs: list0 int): intset

// turning a set into a list
fun intset_listize (xs: intset): list0 (int)

// membership test
fun intset_ismem (xs: intset, x: int): bool

// computing the size of [xs]
fun intset_size (xs: intset): size_t

// adding [x] into [xs]
fun intset_add (xs: intset, x: int): intset

// deleting [x] from [xs]
fun intset_del (xs: intset, x: int): intset

// union of [xs1] and [xs2]
fun intset_union (xs1: intset, xs2: intset): intset

// intersection of [xs1] and [xs2]
fun intset_inter (xs1: intset, xs2: intset): intset

// difference between [xs1] and [xs2]
fun intset_differ (xs1: intset, xs2: intset): intset
")

Let us now suppose that the declaration for #code("intset") and the
above interfaces are all stored in a file named
<filename>intset.sats</filename> (or any other legal name for a static
file).
")#comment("para")

#para("\
Usually, a realistic implementation for finite sets is based on some
kind of balanced trees (e.g., AVL trees, red-black trees). For the purpose
of illustration, we give an implementation in which finite sets of integers
are represented as ordered lists of integers. This implementation is
contained in a file named <filename>intset.dats</filename>, which is
available #mycodelink("CHAPTER_MODULARITY/intset.dats", "on-line").
In order to construct values of an abstract type, we need to concretize it
temporarily by using the following form of declaration:

#atscode("\
assume intset = list0 (int)
")

where #code("assume") is a keyword. This assume-declaration equates
#code("intset") with the type #code("list0 (int)") and this
equation is valid until the end of the scope in which it is introduced. As
the assume-declaration is at the toplevel in
<filename>intset.dats</filename>, the assumption that #code("intset")
equals #code("list0 (int)") is valid until the end of the file. There
is a global restriction in ATS that allows each abstract type to be
concretized by an assume-declaration at most once. More specifically, if an
abstract type is concretized in two files <filename>foo1.dats</filename>
and <filename>foo2.dats</filename>, then these two files cannot be used
together to generate an executable.

The rest of implementation in #code("intset") is all standard.  For
instance, the union operation on two given sets of integers is implemented
as follows:

#atscode("\
implement
intset_union (xs1, xs2) =
  case+ (xs1, xs2) of
  | (list0_cons (x1, xs11), list0_cons (x2, xs21)) =>
      if x1 < x2 then
        list0_cons (x1, intset_union (xs11, xs2))
      else if x1 > x2 then
        list0_cons (x2, intset_union (xs1, xs21))
      else list0_cons (x1, intset_union (xs11, xs21))
  | (list0_nil (), _) => xs2
  | (_, list0_nil ()) => xs1
// end of [intset_union]
")

There is also some testing code available
#mycodelink("CHAPTER_MODULARITY/test_intset.dats", "on-line")
that makes use of some functions declared in
<filename>intset.sats</filename>.  Often testing code as such is
constructed immediately after the interfaces for various functions and
values in a package are declared. This allows these interfaces to be tried
before they are actually implemented so that potential flaws can be exposed
in a timely fashion.
")#comment("para")

</sect1><!--id="abstract_types"-->

<!-- ****** ****** -->

<sect1 id="example_a_package_for_rationals">
<title>
Example: A Package for Rationals
</title>

#para("\
We are to represent a rational number as a pair of integers.  If we
declare a boxed abstract type #code("rat") for values representing
rational numbers, then each value of the type #code("rat") is stored in
heap-allocated memory, which can only be reclaimed through garbage
collection (GC). Instead, we follow an alternative approach by declaring
#code("rat") as an unboxed abstract type. Therefore, a declaration like
the following one is expected:

#atscode("\
abst@ype rat
")

The problem with this declaration is that it is too abstract. As there is
not information given about the size of the type #code("rat"), the ATS
compiler does not even know how much memory is needed for storing a value
of the type #code("rat"). However, the programmer should not assume
that such a form of declaration is useless. There are actually
circumstances where a declaration of this form can be of great importance,
and this is a topic I will cover elsewhere. For now, let us declare an
unboxed abstract type as follows:

#atscode("\
abst@ype rat = (int, int)
")

This declaration simply informs the ATS compiler that the representation
for values of the type #code("rat") is the same as the one for values
of the type #code("(int, int)"). However, this information is not made
available to the typechecker of ATS. In particular, if a value of the type
#code("rat") is treated as a pair of integers in a program, then a
type-error will surely occur.
")#comment("para")

#para("\
The following code is contained in a file named
<filename>ratmod.sats</filename>, which is available
#mycodelink("CHAPTER_MODULARITY/ratmod.sats", "on-line").

#atscode("\
exception Denominator
exception DivisionByZero

fun rat_make_int_int (p: int, q: int): rat

fun ratneg: (rat) -> rat // negation
fun ratadd: (rat, rat) -> rat // addition
fun ratsub: (rat, rat) -> rat // subtraction
fun ratmul: (rat, rat) -> rat // multiplication
fun ratdiv: (rat, rat) -> rat // division
")

The exception #code("Denominator") is for reporting an erroneous occasion
where a rational number is to be formed with a denominator equal to zero.
Given two integers representing the numerator and denominator of a rational
number, the function #code("rat_make_int_int") returns a value representing
the rational number. The following implementation of
#code("rat_make_int_int") can be found in a file named
<filename>ratmod.dats</filename>, which is also available
#mycodelink("CHAPTER_MODULARITY/ratmod.dats", "on-line").

#atscode("\
implement
rat_make_int_int (p, q) = let
  fun make (
    p: int, q: int
  ) : rat = let
    val r = gcd (p, q) in (p / r, q / r)
  end // end of [make]
//
  val () = if q = 0 then $raise Denominator
//
in
  if q > 0 then make (p, q) else make (~p, ~q)
end // end of [rat_make_int_int]
")

Given a pair of integers p and q such that q is not zero, the function
#code("rat_make_int_int") returns another pair of integers
p<subscript>1</subscript> and q<subscript>1</subscript> such that
q<subscript>1</subscript> is positive, p<subscript>1</subscript> and
q<subscript>1</subscript> are coprimes, that is, their greatest common
divisor is 1, and p<subscript>1</subscript>/q<subscript>1</subscript>
equals p/q. With #code("rat_make_int_int"), it is straightforward to
implement as follows the arithmetic operations on rational numbers:

#atscode("\
implement ratneg (x) = (~x.0, x.1)

implement
ratadd (x, y) =
  rat_make_int_int (x.0 * y.1 + x.1 * y.0, x.1 * y.1)
// end of [ratadd]

implement
ratsub (x, y) =
  rat_make_int_int (x.0 * y.1 - x.1 * y.0, x.1 * y.1)
// end of [ratsub]

implement
ratmul (x, y) = rat_make_int_int (x.0 * y.0, x.1 * y.1)

implement
ratdiv (x, y) =
  if y.0 > 0 then rat_make_int_int (x.0 * y.1, x.1 * y.0)
  else $raise DivisionByZero
// end of [ratdiv]
")

There is also some testing code available
#mycodelink("CHAPTER_MODULARITY/test_ratmod.dats", "on-line") that makes
use of some functions declared in <filename>ratmod.sats</filename>.

")#comment("para")

</sect1><!--id="example_a_package_for_rationals"-->

<!-- ****** ****** -->

<sect1 id="example_a_functorial_package_for_rationals">
<title>
Example: A Functorial Package for Rationals
</title>

#para("\
The previous package for rational numbers contains a serious
limitation: The type for the integers employed in the representation of
rational numbers is fixed to be #code("int"). If we ever want to
represent rational numbers based on integers of a different type (for
instance, #code("lint") for long integers or #code("llint") for
long long integers), then we need to implement another package for
rationals based on such integers. It is clearly advantageous to avoid this
style of programming as it involves code duplication to a great
extent.
")

#para("\
The approach we take in this section to implement a package for
rational numbers that can address the aforementioned limitation follows the
idea of functors in the programming language Standard ML (SML). We first
introduce a type definition as follows:

#atscode("\
typedef
intmod (a:t@ype) = '{
  ofint= int -> a
, fprint= (FILEref, a) -> void
, neg= (a) -> a // negation
, add= (a, a) -> a // addition
, sub= (a, a) -> a // subtraction
, mul= (a, a) -> a // multiplication
, div= (a, a) -> a // division
, mod= (a, a) -> a // modulo
, cmp= (a, a) -> int // comparison
} // end of [intmod]
")

Given a type T, #code("intmod")(T) is a boxed record type in which each
field is a function type. A value of the type #code("intmod")(T) is
supposed to represent a module of integer operations on integers
represented by values of the type T. Similarly, we introduce another
type definition as follows:

#atscode("\
abst@ype rat (a:t@ype) = (a, a)

typedef
ratmod (a:t@ype) = '{
  make= (a, a) -<cloref1> rat a
, fprint= (FILEref, rat a) -<cloref1> void
, numer= rat a -> a // numerator
, denom= rat a -> a // denominator
, neg= (rat a) -<cloref1> rat a // negation
, add= (rat a, rat a) -<cloref1> rat a // addition
, sub= (rat a, rat a) -<cloref1> rat a // subtraction
, mul= (rat a, rat a) -<cloref1> rat a // multiplication
, div= (rat a, rat a) -<cloref1> rat a // division
, cmp= (rat a, rat a) -<cloref1> int // comparison
} // end of [ratmod]
")

Given a type T, a value of the type #code("ratmod")(T) is supposed to
represent a module of rational operations on rationals represented by
values of the type #code("rat")(T). The function we need to implement
can now be given the following interface:

#atscode("\
fun{a:t@ype} ratmod_make_intmod (int: intmod a): ratmod a
")

If applied to a given module of integer operations, the function
#code("ratmod_make_intmod") returns a module of rational operations
such that the integers in the former and the latter modules have the same
representation. Therefore, #code("ratmod_make_intmod") behaves like a
functor in SML.  In the following code, we implement two modules
#code("ratmod_int") and #code("ratmod_dbl") of rational operations
in which integers are represented as values of the types #code("int")
and #code("double"), respectively:

#atscode('\
staload M = "libc/SATS/math.sats" // for [fmod]

val intmod_int = \'{
  ofint= lam (i) => i
, fprint= lam (out, x) => fprintf (out, "%i", @(x))
, neg= lam (x) => ~x
, add= lam (x, y) => x + y
, sub= lam (x, y) => x - y
, mul= lam (x, y) => x * y
, div= lam (x, y) => x / y
, mod= lam (x, y) => op mod (x, y)
, cmp= lam (x, y) => compare (x, y)
} : intmod (int) // end of [val]

val ratmod_int = ratmod_make_intmod<int> (intmod_int)

val intmod_dbl = \'{
  ofint= lam (i) => double_of (i)
, fprint= lam (out, x) => fprintf (out, "%0.f", @(x))
, neg= lam (x) => ~x
, add= lam (x, y) => x + y
, sub= lam (x, y) => x - y
, mul= lam (x, y) => x * y
, div= lam (x, y) => $M.trunc (x/y) // trunc: truncation
, mod= lam (x, y) => $M.fmod (x, y) // the modulo function
, cmp= lam (x, y) => compare (x, y)
} : intmod (double) // end of [val]

val ratmod_dbl = ratmod_make_intmod<double> (intmod_dbl)
')

An implementation of the function #code("ratmod_make_intmod") is available
#mycodelink("CHAPTER_MODULARITY/ratfun_rec.dats", "on-line") and there is
some related testing code available
#mycodelink("CHAPTER_MODULARITY/test_ratfun_rec.dats", "on-line") as well.
")#comment("para")

</sect1><!--id="example_a_functorial_package_for_rationals"-->

<!-- ****** ****** -->

<sect1 id="specific_template_implementation">
<title>
Specific Template Implementation
</title>

#para("\
Implementing an interface for a function template specifically means
to give an implementation for a fixed instance of the template. For
instance, the following interface is for a function template of the name
#code("eq_elt_elt"):

#atscode("\
fun{a:t@ype} eq_elt_elt (x: a, y: a): bool // a generic equality
")

There is no meaningful generic implementation for #code("eq_elt_elt") as
equality test for values of a type T depends on T.  Two specific template
implementations are given as follows for the instances
#code("eq_elt_elt&lt;int&gt;") and
#code("eq_elt_elt&lt;double&gt;"):

#atscode("\
implement eq_elt_elt<int> (x, y) = eq_int_int (x, y)
implement eq_elt_elt<double> (x, y) = eq_double_double (x, y)
")

where #code("eq_int_int") and #code("eq_double_double") are
equality functions for values of the type #code("int") and
#code("double"), respectively. It is also possible to give the
implementations as follows:

#atscode("\
implement eq_elt_elt<int> (x, y) = (x = y)
implement eq_elt_elt<double> (x, y) = (x = y)
")

This is allowed as the symbol #code("=") is already overloaded with
#code("eq_int_int") and #code("eq_double_double") (in addition to
many other functions).
")#comment("para")

#para("\
Let us now see a typical use of specific template implementation.
The following defined function template #code("listeq") implements
an equality function on lists:

#atscode("\
fun{a:t@ype}
listeq (xs: list0 a, ys: list0 a): bool =
  case+ (xs, ys) of
  | (list0_cons (x, xs),
     list0_cons (y, ys)) => 
      if eq_elt_elt<a> (x, y) then listeq (xs, ys) else false
  | (list0_nil (), list0_nil ()) => true
  | (_, _) => false
// end of [listeq]
")

Given two lists xs and ys, #code("listeq") returns #code("true") if
and only if xs and ys are of the same length and each element in xs equals
the corresponding one in ys based on a call to #code("eq_elt_elt").
Given a type T, it is clear that the instance
#code("eq_elt_elt&lt;")T#code("&gt;") is needed if
#code("listeq") is called on two lists of the type
#code("list0")(T). In other words, a specific implementation for
#code("eq_elt_elt&lt;")T#code("&gt;") should be given if a call to
#code("listeq") is to be made on two lists of the type
#code("list0")(T). Note that the implementation for an instance of a
function template is required to be present in the same file where the
instance is called.
")#comment("para")

#para("\
As a comparison, the following defined function template
#code("listeqf") also implements equality test on two given lists:

#atscode("\
fun{a:t@ype}
listeqf (
  xs: list0 a, ys: list0 a, eq: (a, a) -> bool
) : bool =
  case+ (xs, ys) of
  | (list0_cons (x, xs),
     list0_cons (y, ys)) => 
      if eq (x, y) then listeqf (xs, ys, eq) else false
  | (list0_nil (), list0_nil ()) => true
  | (_, _) => false
// end of [listeqf]
")

In this case, #code("listeqf") takes an additional argument
#code("eq") that tests whether two list elements are equal.  Both
#code("listeq") and #code("listeqf") have advantages over the
other. The former is a first-order function while the latter is a
higher-order one, and thus it is likely for the former to be compiled into
more efficient object code. However, the latter often seems more convenient
for use in practice.
")#comment("para")

#para("\
Please find the code presented in this section plus some additional
testing code available #mycodelink("CHAPTER_MODULARITY/listeq.dats", "on-line").
")

</sect1>

<!-- ****** ****** -->

<sect1 id="example_a_temptorial_package_for_rationals">
<title>
Example: A Temptorial Package for Rationals
</title>

#para("\
As I have great difficulty in naming the style of programming I am
about to present in this section, I coin a word
<emphasis>temptorial</emphasis> (as a shorthand for template-functorial) to
refer to this style, which makes essential use of function templates that
are implemented generically as well as specifically.
")

#para("\
Suppose that we have interfaces for two function templates foo and
bar.  We give a generic template implementation for bar that makes use of
foo but we cannot or do not want to implement foo generically. When an
instance of bar is called, certain instances of foo may need to be
implemented specifically so as to support the call. Let us now imagine a
design where foo and bar are replaced with collections of function
templates corresponding to various operations on integers and rationals.
This is precisely the idea employed in the design of a temptorial package
for rationals.
")

#para("\
The following interfaces for function templates are declared in a
file named <filename>ratfun_tmp.sats</filename>, which is available
#mycodelink("CHAPTER_MODULARITY/ratfun_tmp.sats", "on-line"):

#atscode("\
fun{a:t@ype} ofint: int -> a
fun{a:t@ype} fprint_int (out: FILEref, x: a): void

fun{a:t@ype} intneg: a -> a
fun{a:t@ype} intadd: (a, a) -> a
fun{a:t@ype} intsub: (a, a) -> a
fun{a:t@ype} intmul: (a, a) -> a
fun{a:t@ype} intdiv: (a, a) -> a
fun{a:t@ype} intmod: (a, a) -> a

fun{a:t@ype} intcmp: (a, a) -> int

(* ^^^^^^ ^^^^^^ *)
//
// the following templates are implemented based on the above ones
//
(* vvvvvv vvvvvv *)

fun{a:t@ype} intgcd: (a, a) -> a

fun{a:t@ype} intlt: (a, a) -> bool
fun{a:t@ype} intlte: (a, a) -> bool
fun{a:t@ype} intgt: (a, a) -> bool
fun{a:t@ype} intgte: (a, a) -> bool
fun{a:t@ype} inteq: (a, a) -> bool
fun{a:t@ype} intneq: (a, a) -> bool

abst@ype rat (a: t@ype) = (a, a)

fun{a:t@ype} rat_make_int_int (p: int, q: int): rat a
fun{a:t@ype} rat_make_numer_denom (p: a, q: a): rat a

fun{a:t@ype} fprint_rat (out: FILEref, x: rat a): void

fun{a:t@ype} rat_numer (x: rat a): a
fun{a:t@ype} rat_denom (x: rat a): a

fun{a:t@ype} ratneg: (rat a) -> rat a
fun{a:t@ype} ratadd: (rat a, rat a) -> rat a
fun{a:t@ype} ratsub: (rat a, rat a) -> rat a
fun{a:t@ype} ratmul: (rat a, rat a) -> rat a
fun{a:t@ype} ratdiv: (rat a, rat a) -> rat a

fun{a:t@ype} ratcmp: (rat a, rat a) -> int
")

In another file named <filename>ratfun_tmp.dats</filename>, which is also
available #mycodelink("CHAPTER_MODULARITY/ratfun_tmp.dats", "on-line"), the
second half of the above interfaces for function templates are implemented
based on the function templates for which the interfaces are declared in
the first half. As an example, the function template
#code("rat_make_numer_denom") is implemented as follows:

#atscode("\
implement{a}
rat_make_numer_denom (p, q) = let
  fun make (p: a, q: a): rat a = let
    val r = intgcd (p, q) in (p \intdiv r, q \intdiv r)
  end // end of [make]
in
  if intgtz (q)
    then make (p, q) else make (intneg p, intneg q)
  // end of [if]
end // end of [rat_make_numer_denom]
")

Note that the backslash symbol (#code("\\\\")) temporarily assigns the
infix status to the identifier immediately following it.  For instance, the
syntax #code("p \intdiv r") simply stands for the function application
#code("intdiv(p, r)").
")#comment("para")

#para("\
There is some testing code available
#mycodelink("CHAPTER_MODULARITY/test_ratfun_tmp.dats", "on-line") that
demonstrates a typical way to use a temptorial package. For instance, if we
want to use a package for rationals where integers are represented as
values of the type #code("double"), then we can first give the following
specific implementations for instances of function templates corresponding
to certain integer operations:

#atscode('\
staload M = "libc/SATS/math.sats" // for [fmod]

typedef T = double
implement ofint<T> (x) = double_of (x)
implement fprint_int<T> (out, x) = fprintf (out, "%.0f", @(x))

implement intneg<T> (x) = ~x
implement intadd<T> (x, y) = x + y
implement intsub<T> (x, y) = x - y
implement intmul<T> (x, y) = x * y
implement intdiv<T> (x, y) = $M.trunc (x/y) // trunc: truncation
implement intmod<T> (x, y) = $M.fmod (x, y) // modulo operation

implement intcmp<T> (x, y) = compare (x, y)
')

With these implementations, we can call the corresponding instances of
those function templates in <filename>ratfun_tmp.sats</filename> (e.g.,
#code("ratadd&lt;double&gt;") and #code("ratsub&lt;double&gt;"))
that have already been implemented generically.
")#comment("para")

</sect1><!--id="example_a_temptorial_package_for_rationals"-->

</chapter><!--id="modularity"-->

#comment(" ****** ****** ")

#comment(" end of [main.atxt] ")

%{
implement main () = fprint_filsub (stdout_ref, "main_atxt.txt")
%}
